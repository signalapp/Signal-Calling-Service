//
// Copyright 2021 Signal Messenger, LLC
// SPDX-License-Identifier: AGPL-3.0-only
//

use std::{
    cmp::min,
    collections::{HashMap, HashSet, VecDeque},
    convert::{From, TryFrom},
    fmt::{self, Display, Formatter},
    sync::Arc,
    time::SystemTime,
};

use hex::ToHex;
use log::*;
use prost::Message;
use thiserror::Error;

use crate::{
    audio,
    common::{DataRate, DataSize, Duration, Instant, VideoHeight},
    protos, rtp, vp8,
};

pub const CLIENT_SERVER_DATA_SSRC: rtp::Ssrc = 1;
pub const CLIENT_SERVER_DATA_PAYLOAD_TYPE: rtp::PayloadType = 101;

/// This is for throttling the CPU usage of calculating what key frame requests
/// to send.  A higher value should use less CPU and a lower value should
/// send key frame requests with less delay.
const KEY_FRAME_REQUEST_CALCULATION_INTERVAL: Duration = Duration::from_millis(5);
/// For a particular SSRC, we only want to send a key frame request this often.
/// Sending more often than this probably doesn't help any and wastes bandwidth.
const KEY_FRAME_REQUEST_RESEND_INTERVAL: Duration = Duration::from_millis(200);
/// Even if the target send rate changes really frequently,
/// don't reallocate it more often than this.
/// A lower value uses more CPU but makes layer switching more reactive.
const SEND_RATE_REALLOCATION_INTERVAL: Duration = Duration::from_millis(1000);
/// This is how often we recaculate the active speaker.
/// The lower the value, the more CPU we use but the more responsive
/// active speaker switching becomes.
const ACTIVE_SPEAKER_CALCULATION_INTERVAL: Duration = Duration::from_millis(300);
/// This is how often we send stats down to the client
const STATS_MESSAGE_INTERVAL: Duration = Duration::from_secs(1);

/// A wrapper around Vec<u8> to identify a Call.
/// It comes from signaling, but isn't known by the clients.
// It would be easier to change this to a u64, and we don't have
// to change the clients to do so.  Just the SFU frontend.
// Note that this is deliberately not Debug; see LoggableCallId.
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct CallId(Arc<[u8]>);

impl From<Vec<u8>> for CallId {
    fn from(call_id: Vec<u8>) -> Self {
        Self(call_id.into())
    }
}

impl CallId {
    pub fn as_slice(&self) -> &[u8] {
        &self.0
    }
}

/// A truncated call ID that is suitable for logging.
#[derive(Clone, Debug)]
pub struct LoggableCallId {
    /// The truncated hex string version of this call's id.
    truncated_call_id_for_logging: String,
}

impl From<&CallId> for LoggableCallId {
    fn from(call_id: &CallId) -> Self {
        Self::from(call_id.as_slice())
    }
}

impl From<&[u8]> for LoggableCallId {
    fn from(data: &[u8]) -> Self {
        let truncated_call_id_for_logging = {
            if data.is_empty() {
                "<EMPTY>".to_string()
            } else {
                let first_3_bytes_of_id = data.chunks(3).next().unwrap();
                first_3_bytes_of_id.encode_hex::<String>()
            }
        };
        LoggableCallId {
            truncated_call_id_for_logging,
        }
    }
}

impl Display for LoggableCallId {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        f.write_str(&self.truncated_call_id_for_logging)
    }
}

/// A wrapper around Vec<u8> to identify a user.
/// It comes from signaling and is actually an opaque value
/// generated by clients, not a UUID.
#[derive(Clone, PartialEq, Eq)]
pub struct UserId(Vec<u8>);

impl From<Vec<u8>> for UserId {
    fn from(user_id: Vec<u8>) -> Self {
        Self(user_id)
    }
}

impl UserId {
    pub fn as_slice(&self) -> &[u8] {
        self.0.as_slice()
    }
}

/// A wrapper around a u32 with the 4 LSBs set to 0.
/// Uniquely identifies a client within a call (scoped to the CallId).
/// Used for generating SSRCs, and can be inferred from an SSRC.
#[derive(Clone, Debug, Eq, PartialEq, Copy, Hash, PartialOrd, Ord)]
pub struct DemuxId(u32);

impl DemuxId {
    pub fn as_u32(self) -> u32 {
        self.0
    }
}

impl TryFrom<u32> for DemuxId {
    type Error = Error;
    fn try_from(demux_id: u32) -> Result<Self, Error> {
        if demux_id & 0b1111 == 0 {
            Ok(Self(demux_id))
        } else {
            Err(Error::InvalidDemuxId(demux_id))
        }
    }
}

impl From<DemuxId> for u32 {
    fn from(demux_id: DemuxId) -> u32 {
        demux_id.0
    }
}

impl DemuxId {
    fn from_ssrc(ssrc: rtp::Ssrc) -> Self {
        Self(ssrc & 0b1111_1111_1111_1111_1111_1111_1111_0000)
    }
}

/// Identifies one of the "layers" that can be combined with a
/// DemuxID to create an SSRC.  Can be inferred from an SSRC.
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]
#[repr(u8)]
pub enum LayerId {
    // SSRC offsets 1, 3, 5, and 7 are for RTX.
    Audio = 0,
    Video0 = 2,
    Video1 = 4,
    Video2 = 6,
    RtpData = 0xD,
}

impl LayerId {
    fn from_ssrc(ssrc: rtp::Ssrc) -> Option<Self> {
        Some(match (ssrc & 0b1111) as u8 {
            0 => LayerId::Audio,
            2 => LayerId::Video0,
            4 => LayerId::Video1,
            6 => LayerId::Video2,
            0xD => LayerId::RtpData,
            _ => {
                return None;
            }
        })
    }

    fn from_video_layer_index(video_layer_index: usize) -> Option<Self> {
        Some(match video_layer_index {
            0 => LayerId::Video0,
            1 => LayerId::Video1,
            2 => LayerId::Video2,
            _ => {
                return None;
            }
        })
    }

    pub fn to_ssrc(self, demux_id: DemuxId) -> rtp::Ssrc {
        u32::from(demux_id) | (self as u32)
    }

    pub fn to_rtx_ssrc(self, demux_id: DemuxId) -> rtp::Ssrc {
        rtp::to_rtx_ssrc(self.to_ssrc(demux_id))
    }
}

#[derive(Error, Debug, Eq, PartialEq)]
pub enum Error {
    #[error("received RTP data for server with invalid protobuf")]
    InvalidClientToServerProtobuf,
    #[error("received RTP packet with unauthorized SSRC.  Authorized DemuxId: {0:?}.  Received DemuxId: {1:?}")]
    UnauthorizedRtpSsrc(DemuxId, DemuxId),
    #[error("received RTP packet with invalid VP8 header")]
    InvalidVp8Header,
    #[error("received RTP packet with invalid layer ID")]
    InvalidRtpLayerId,
    #[error("unknown demux ID: {0:?}")]
    UnknownDemuxId(DemuxId),
    #[error("Invalid demux ID: {0:?}")]
    InvalidDemuxId(u32),
}

/// Represents an RTP packet that should be sent to a particular client
/// of the call, identified by DemuxId.
type RtpToSend = (DemuxId, rtp::Packet<Vec<u8>>);
/// Represents a KeyFrameRequest that should be sent to a particular client
/// of the call, identified by DemuxId.
type KeyFrameRequestToSend = (DemuxId, rtp::KeyFrameRequest);

/// A collection of clients between which media is forwarded.
/// Each client sends and receives media (audio, video, or data).
/// Media is forwarded from every client to every other client.
/// Video is constrained by congestion control and video requests.
/// Request for video key frames are also forwarded.
/// Key frame requests may be generated when to allow for switching between
/// different video spatial layers.
pub struct Call {
    // Immutable
    loggable_call_id: LoggableCallId,
    creator_id: UserId,  // AKA the first user to join
    created: SystemTime, // For knowing how old the call is
    active_speaker_message_interval: Duration,
    initial_target_send_rate: DataRate,
    default_requested_max_send_rate: DataRate,

    /// Clients (AKA devices) that have joined the call
    clients: Vec<Client>,
    /// The last time a client was added or removed
    client_added_or_removed: Instant,
    /// The last time a clients update was sent to the clients
    clients_update_sent: Instant,

    /// The active speaker, if there is one
    /// This is calculated based on incoming audio levels
    active_speaker_ids: Option<(DemuxId, String)>,
    /// The last time the active speaker was calculated
    active_speaker_calculated: Instant,
    /// The last time an active speaker update was sent to the clients
    active_speaker_update_sent: Instant,

    /// The last time a status update was sent to the clients
    stats_update_sent: Instant,

    /// The last time key frame requests were sent, in general and specifically for certain SSRCs
    key_frame_requests_sent: Instant,
    key_frame_request_sent_by_ssrc: HashMap<rtp::Ssrc, Instant>,
}

/// Info we need to transfer from the Call to the Connection
/// In particular, we need to be able to do 2 things:
/// 1.  Send padding at a certain rate.
/// 2.  Reset congestion control
#[derive(Debug, PartialEq, Eq)]
pub struct SendRateAllocationInfo {
    pub demux_id: DemuxId,
    pub padding_send_rate: DataRate,
    pub padding_ssrc: Option<rtp::Ssrc>,
    pub requested_base_rate: DataRate,
    pub ideal_send_rate: DataRate,
}

impl Call {
    pub fn new(
        loggable_call_id: LoggableCallId,
        creator_id: UserId,
        active_speaker_message_interval: Duration,
        initial_target_send_rate: DataRate,
        default_requested_max_send_rate: DataRate,
        now: Instant,
        system_now: SystemTime,
    ) -> Self {
        info!("call: {} creating", loggable_call_id);
        Self {
            loggable_call_id,
            creator_id,
            created: system_now,
            active_speaker_message_interval,
            initial_target_send_rate,
            default_requested_max_send_rate,

            clients: Vec::new(),
            client_added_or_removed: now,
            clients_update_sent: now,

            active_speaker_ids: None,
            active_speaker_calculated: now - ACTIVE_SPEAKER_CALCULATION_INTERVAL, // easier than using None :)
            active_speaker_update_sent: now,

            stats_update_sent: now, // easier than using None :)

            key_frame_requests_sent: now - KEY_FRAME_REQUEST_CALCULATION_INTERVAL, // easier than using None :)
            key_frame_request_sent_by_ssrc: HashMap::new(),
        }
    }

    pub fn loggable_call_id(&self) -> &LoggableCallId {
        &self.loggable_call_id
    }

    pub fn creator_id(&self) -> &UserId {
        &self.creator_id
    }

    pub fn is_empty(&self) -> bool {
        self.clients.is_empty()
    }

    pub fn size(&self) -> usize {
        self.clients.len()
    }

    pub fn client_added_or_removed(&self) -> Instant {
        self.client_added_or_removed
    }

    pub fn created(&self) -> SystemTime {
        self.created
    }

    pub fn has_client(&self, demux_id: DemuxId) -> bool {
        self.clients
            .iter()
            .any(|client| client.demux_id == demux_id)
    }

    pub fn add_client(
        &mut self,
        demux_id: DemuxId,
        user_id: UserId, // only used for stats
        active_speaker_id: String,
        resolution_request_id: u64,
        now: Instant,
    ) {
        time_scope_us!("calling.call.add_client");

        self.clients.push(Client::new(
            demux_id,
            user_id,
            active_speaker_id,
            resolution_request_id,
            self.default_requested_max_send_rate,
            now,
        ));
        // An update message to clients about clients will be sent at the next tick().
        self.client_added_or_removed = now;
        self.allocate_target_send_rate(demux_id, self.initial_target_send_rate, now);
        // We may have to update the padding SSRCs because there can't be any padding SSRCs until two people join
        self.update_padding_ssrcs();
    }

    pub fn remove_client(&mut self, demux_id: DemuxId, now: Instant) {
        time_scope_us!("calling.call.remove_client");

        if let Some(index) = self
            .clients
            .iter()
            .position(|client| client.demux_id == demux_id)
        {
            self.clients.swap_remove(index);

            // An update message to clients about clients will be sent at the next tick().
            self.client_added_or_removed = now;
            self.reallocate_target_send_rates(now);
            self.update_padding_ssrcs();
        }
    }

    /// This updates the SSRCs that will be used to send padding.  We have to keep updating them
    /// because they have to be an SSRC of another client, which means there aren't any padding
    /// SSRCs until there are at least 2 clients in the call.
    fn update_padding_ssrcs(&mut self) {
        // We only send padding using an RTX SSRC. It doesn't matter which one.
        // The receiving client is configured to receive RTX for the base video 0
        // for each of the other clients in the call. So we have to pick one of those.
        // And the easiest one to pick is the RTX SSRC for the video base layer for
        // the given sender.demux_id.
        let padding_ssrc = |sender: &Client| Some(LayerId::Video0.to_rtx_ssrc(sender.demux_id));

        match self.clients.as_mut_slice() {
            [] => {
                // Nothing to update
            }
            [lonely] => {
                // Padding is not possible
                lonely.padding_ssrc = None;
            }
            [first, second, rest @ ..] => {
                // Just pick someone else.  The easiest way is to pick the first unless you're the first.
                first.padding_ssrc = padding_ssrc(second);
                second.padding_ssrc = padding_ssrc(first);
                for receiver in rest {
                    receiver.padding_ssrc = padding_ssrc(first);
                }
            }
        }
    }

    /// For a given packet from the sending client, determine what packets to
    /// send out to the other clients. This may include packets to forward
    /// and packets that update clients about active speaker changes and clients
    /// added and removed.  If the SSRC of the packet doesn't match the DemuxId,
    /// a UnauthorizedRtpSsrc error will be returned.
    /// If the DemuxId is unknown, an UnknownDemuxId error will be returned.
    pub fn handle_rtp(
        &mut self,
        sender_demux_id: DemuxId,
        incoming_rtp: rtp::Packet<&mut [u8]>,
        now: Instant,
    ) -> Result<Vec<RtpToSend>, Error> {
        if incoming_rtp.ssrc() == CLIENT_SERVER_DATA_SSRC
            && incoming_rtp.payload_type() == CLIENT_SERVER_DATA_PAYLOAD_TYPE
        {
            time_scope_us!("calling.call.handle_rtp.client_to_server_data");

            let proto = protos::DeviceToSfu::decode(incoming_rtp.payload())
                .map_err(|_| Error::InvalidClientToServerProtobuf)?;

            // Snapshot these so we can get a mutable reference to the sender.
            let default_requested_max_send_rate = self.default_requested_max_send_rate;
            let demux_id_by_resolution_request_id: HashMap<u64, DemuxId> = self
                .clients
                .iter()
                .map(|client| (client.resolution_request_id, client.demux_id))
                .collect();

            let sender = self
                .find_client_mut(sender_demux_id)
                .ok_or(Error::UnknownDemuxId(sender_demux_id))?;

            if proto.leave.is_some() {
                info!(
                    "call: {} removing client: {} (via RTP)",
                    self.loggable_call_id(),
                    sender_demux_id.as_u32()
                );
                self.remove_client(sender_demux_id, now);
                return Ok(vec![]);
            }

            // The client resends this periodically, so we don't want to do anything
            // if it didn't change.
            if proto.video_request != sender.video_request_proto {
                if let Some(video_request_proto) = proto.video_request {
                    sender.requested_height_by_demux_id = video_request_proto
                        .requests
                        .iter()
                        .filter_map(|request| {
                            let raw_height = request.height?;
                            let height = VideoHeight::from(raw_height as u16);

                            if let Some(raw_demux_id) = request.demux_id {
                                let demux_id = DemuxId::try_from(raw_demux_id).ok()?;
                                Some((demux_id, height))
                            } else if let Some(resolution_request_id) = request.short_device_id {
                                demux_id_by_resolution_request_id
                                    .get(&resolution_request_id)
                                    .map(|demux_id| (*demux_id, height))
                            } else {
                                None
                            }
                        })
                        .collect();
                    sender.requested_max_send_rate = video_request_proto
                        .max_kbps
                        .map(|kbps| DataRate::from_kbps(kbps as u64))
                        .unwrap_or(default_requested_max_send_rate);
                    sender.video_request_proto = Some(video_request_proto);
                    // We reallocate immediately to make a more pleasant expereience for the user
                    // (no extra delay for selecting a higher resolution or requesting a new max send rate)
                    let target_send_rate = sender.target_send_rate;
                    self.allocate_target_send_rate(sender_demux_id, target_send_rate, now);
                }
            }
            // There's nothing to forward
            return Ok(vec![]);
        }

        // Make sure to do this before processing audio level, etc.
        // Otherwise someone could fake the SSRC to change active speaker and that sort of thing.
        let authorized_sender_demux_id = DemuxId::from_ssrc(incoming_rtp.ssrc());
        if authorized_sender_demux_id != sender_demux_id {
            return Err(Error::UnauthorizedRtpSsrc(
                authorized_sender_demux_id,
                sender_demux_id,
            ));
        }

        let sender = self
            .find_client_mut(sender_demux_id)
            .ok_or(Error::UnknownDemuxId(sender_demux_id))?;

        let incoming_rtp = incoming_rtp.borrow();
        let incoming_vp8 = if incoming_rtp.payload_type() == rtp::VP8_PAYLOAD_TYPE {
            time_scope_us!("calling.call.handle_rtp.vp8_header");
            let incoming_vp8 = sender
                .parse_vp8_header_and_update_incoming_video_rate_and_resolution(&incoming_rtp, now)
                .ok_or(Error::InvalidVp8Header)?;
            Some(incoming_vp8)
        } else {
            None
        };

        let mut rtp_to_send = vec![];
        if let Some(audio_level) = incoming_rtp.audio_level {
            time_scope_us!("calling.call.handle_rtp.audio_level");
            sender.incoming_audio_levels.push(audio_level);
            // Active speaker is recalculated in tick()
        }

        let layer_id = LayerId::from_ssrc(incoming_rtp.ssrc()).ok_or(Error::InvalidRtpLayerId)?;

        time_scope_us!("calling.call.handle_rtp.forwarding");

        for receiver in &mut self.clients {
            if receiver.demux_id == sender_demux_id {
                // Don't send to yourself.
                continue;
            }
            if let Some(rtp_to_forward) = match layer_id {
                LayerId::Audio => {
                    let is_silence = incoming_rtp.audio_level == Some(0);
                    if is_silence {
                        None
                    } else {
                        receiver.forward_audio_rtp(&incoming_rtp)
                    }
                }
                LayerId::RtpData => receiver.forward_data_rtp(&incoming_rtp),
                LayerId::Video0 | LayerId::Video1 | LayerId::Video2 => {
                    receiver.forward_video_rtp(&incoming_rtp, incoming_vp8.as_ref())
                }
            } {
                rtp_to_send.push((receiver.demux_id, rtp_to_forward));
            }
        }
        Ok(rtp_to_send)
    }

    /// Update state that only needs to be updated regularly, such as
    /// incoming data rates, send rate allocations, and the active speaker.
    /// Send packets to clients that should either be delayed or be sent regularly,
    /// such as key frame requests and active speaker changes.
    pub fn tick(&mut self, now: Instant) -> (Vec<RtpToSend>, Vec<KeyFrameRequestToSend>) {
        time_scope_us!("calling.call.tick");

        for sender in &mut self.clients {
            sender.incoming_video0.rate_tracker.update(now);
            sender.incoming_video1.rate_tracker.update(now);
            sender.incoming_video2.rate_tracker.update(now);
        }

        let mut active_speaker_just_changed = false;
        if now > self.active_speaker_calculated + ACTIVE_SPEAKER_CALCULATION_INTERVAL {
            time_scope_us!("calling.call.tick.calculate_active_speaker");

            self.active_speaker_calculated = now;
            let new_active_speaker = self.calculate_active_speaker(now);
            if new_active_speaker.is_some() {
                trace!("  active speaker changed");
                trace!("  send rtp packet with active speaker change to all clients in the sender's call");
                active_speaker_just_changed = true;
                // update proto is sent down below
            }
        }

        // A change to the layer rate or resolution may impact how the receiver allocates the target sent rate.
        // So can a change in active speaker.
        // So we should reallocate after changing the incoming rates above and active speaker above.
        self.reallocate_target_send_rates_if_its_been_too_long(now);

        // Do this after reallocation so it has the latest info about what is being forwarded.
        let mut rtp_to_send = vec![];
        self.send_update_proto_to_all_clients(active_speaker_just_changed, &mut rtp_to_send, now);

        // Reallocation can change what key frames to send, so we should do this after reallocating.
        let key_frame_requests_to_send = self.send_key_frame_requests_if_its_been_too_long(now);

        (rtp_to_send, key_frame_requests_to_send)
    }

    /// Adjust the target send rate for the given client according to what congestion control has
    /// calculated.
    pub fn set_target_send_rate(
        &mut self,
        receiver_demux_id: DemuxId,
        new_target_send_rate: DataRate,
    ) -> Result<(), Error> {
        let receiver = self
            .find_client_mut(receiver_demux_id)
            .ok_or(Error::UnknownDemuxId(receiver_demux_id))?;
        receiver.target_send_rate = new_target_send_rate;
        Ok(())
    }

    pub fn get_send_rate_allocation_info(
        &self,
    ) -> impl Iterator<Item = SendRateAllocationInfo> + '_ {
        self.clients.iter().map(|client| SendRateAllocationInfo {
            demux_id: client.demux_id,
            padding_send_rate: client.padding_send_rate,
            padding_ssrc: client.padding_ssrc,
            requested_base_rate: client.requested_base_rate,
            ideal_send_rate: client.ideal_send_rate,
        })
    }

    fn reallocate_target_send_rates_if_its_been_too_long(&mut self, now: Instant) {
        let receivers: Vec<(DemuxId, DataRate)> = self
            .clients
            .iter()
            .filter_map(|receiver| {
                if now > (receiver.send_rate_allocated + SEND_RATE_REALLOCATION_INTERVAL) {
                    Some((receiver.demux_id, receiver.target_send_rate))
                } else {
                    None
                }
            })
            .collect();

        for (receiver_demux_id, target_send_rate) in receivers {
            self.allocate_target_send_rate(receiver_demux_id, target_send_rate, now);
        }
    }

    fn reallocate_target_send_rates(&mut self, now: Instant) {
        let receivers: Vec<(DemuxId, DataRate)> = self
            .clients
            .iter()
            .map(|client| (client.demux_id, client.target_send_rate))
            .collect();
        for (receiver_demux_id, target_send_rate) in receivers {
            self.allocate_target_send_rate(receiver_demux_id, target_send_rate, now);
        }
    }

    /// Adjust the target send rate for the given client according to what congestion control has
    /// calculated.
    fn allocate_target_send_rate(
        &mut self,
        receiver_demux_id: DemuxId,
        new_target_send_rate: DataRate,
        now: Instant,
    ) {
        let receiver = self
            .find_client(receiver_demux_id)
            .expect("Client exists before trying to allocate target send rate");

        // We have to collect these because we can't get a mutable ref to the receiver while getting
        // immutable refs to the senders.
        let allocatable_videos: Vec<AllocatableVideo> = self
            .clients
            .iter()
            .filter_map(|sender| {
                if sender.demux_id == receiver_demux_id {
                    // Don't send video to yourself
                    return None;
                }
                Some(AllocatableVideo {
                    sender_demux_id: sender.demux_id,
                    layers: [
                        sender.incoming_video0.as_allocatable_layer(),
                        sender.incoming_video1.as_allocatable_layer(),
                        sender.incoming_video2.as_allocatable_layer(),
                    ],
                    requested_height: receiver
                        .requested_height_by_demux_id
                        .get(&sender.demux_id)
                        .copied()
                        .unwrap_or_else(|| VideoHeight::from(1)),
                    interesting: sender.became_active_speaker,
                })
            })
            .collect();
        let receiver = self.find_client_mut(receiver_demux_id).unwrap();

        // We have to collect these because we can't get a mutable ref to the receiver while getting
        // immutable refs to the senders.
        let sender_demux_ids: Vec<DemuxId> = allocatable_videos
            .iter()
            .map(|video| video.sender_demux_id)
            .filter(|sender_demux_id| *sender_demux_id != receiver.demux_id)
            .collect();
        let requested_base_rate =
            requested_base_rate(&allocatable_videos, receiver.requested_max_send_rate);
        let ideal_send_rate =
            ideal_send_rate(&allocatable_videos, receiver.requested_max_send_rate);
        let allocated_video_by_sender_demux_id =
            allocate_send_rate(new_target_send_rate, ideal_send_rate, allocatable_videos);
        let allocated_send_rate = allocated_video_by_sender_demux_id
            .values()
            .map(|allocated| allocated.rate)
            .sum();

        for sender_demux_id in sender_demux_ids {
            let desired_incoming_ssrc = allocated_video_by_sender_demux_id
                .get(&sender_demux_id)
                .map(|allocated_video| {
                    let layer_id =
                        LayerId::from_video_layer_index(allocated_video.layer_index).unwrap();
                    layer_id.to_ssrc(allocated_video.sender_demux_id)
                });
            let forwarder = receiver
                .video_forwarder_by_sender_demux_id
                .entry(sender_demux_id)
                .or_insert_with(|| {
                    let outgoing_ssrc = LayerId::Video0.to_ssrc(sender_demux_id);
                    Vp8SimulcastRtpForwarder::new(outgoing_ssrc)
                });
            forwarder.set_desired_ssrc(desired_incoming_ssrc);
        }

        let padding_send_rate =
            min(ideal_send_rate, new_target_send_rate).saturating_sub(allocated_send_rate);

        receiver.target_send_rate = new_target_send_rate;
        receiver.requested_base_rate = requested_base_rate;
        receiver.ideal_send_rate = ideal_send_rate;
        receiver.allocated_send_rate = allocated_send_rate;
        receiver.padding_send_rate = padding_send_rate;
        receiver.send_rate_allocated = now;
    }

    pub fn handle_key_frame_requests(
        &mut self,
        requester_id: DemuxId,
        key_frame_requests: &[rtp::KeyFrameRequest],
        now: Instant,
    ) -> Vec<(DemuxId, rtp::KeyFrameRequest)> {
        let requester = self.find_client_mut(requester_id);
        if requester.is_none() {
            return vec![];
        }
        let requester = requester.unwrap();

        for key_frame_request in key_frame_requests {
            // This might not send them immediately because we might have just sent one
            // and this still has to respect throttling.
            let video_sender_demux_id = DemuxId::from_ssrc(key_frame_request.ssrc);
            let video_forwarder = requester
                .video_forwarder_by_sender_demux_id
                .get_mut(&video_sender_demux_id);
            if let Some(video_forwarder) = video_forwarder {
                video_forwarder.set_needs_key_frame();
            }
        }
        self.send_key_frame_requests_if_its_been_too_long(now)
    }

    fn find_client(&self, demux_id: DemuxId) -> Option<&Client> {
        self.clients
            .iter()
            .find(|client| client.demux_id == demux_id)
    }

    fn find_client_mut(&mut self, demux_id: DemuxId) -> Option<&mut Client> {
        self.clients
            .iter_mut()
            .find(|client| client.demux_id == demux_id)
    }

    fn send_update_proto_to_all_clients(
        &mut self,
        active_speaker_just_changed: bool,
        rtp_to_send: &mut Vec<RtpToSend>,
        now: Instant,
    ) {
        let mut update = protos::SfuToDevice::default();

        if self.client_added_or_removed > self.clients_update_sent {
            // The fields aren't used by the client, so they are None.
            update.device_joined_or_left =
                Some(protos::sfu_to_device::DeviceJoinedOrLeft::default());
            self.clients_update_sent = now;
        }

        if active_speaker_just_changed
            || update.device_joined_or_left.is_some()
            || (now >= self.active_speaker_update_sent + self.active_speaker_message_interval)
        {
            if let Some((demux_id, active_speaker_id)) = self.active_speaker_ids.as_ref() {
                update.speaker = Some(protos::sfu_to_device::Speaker {
                    long_device_id: Some(active_speaker_id.clone()),
                    demux_id: Some(demux_id.as_u32()),
                });
            }
            self.active_speaker_update_sent = now;
        }

        let send_stats = now >= self.stats_update_sent + STATS_MESSAGE_INTERVAL;
        if update.device_joined_or_left.is_some() || update.speaker.is_some() || send_stats {
            let raw_demux_ids: Vec<u32> = self
                .clients
                .iter()
                .map(|client| client.demux_id.as_u32())
                .collect();

            for client in &mut self.clients {
                update.current_devices = Some(protos::sfu_to_device::CurrentDevices {
                    all_demux_ids: raw_demux_ids.clone(),
                    demux_ids_with_video: client
                        .video_forwarder_by_sender_demux_id
                        .iter()
                        .filter_map(|(demux_id, forwarder)| {
                            // We don't want the clients to draw an empty box when a key frame might be coming soon,
                            // so we count it as forwarding if we're still waiting for a key frame.
                            if forwarder.forwarding_ssrc().is_some()
                                || forwarder.needs_key_frame().is_some()
                            {
                                Some(demux_id.as_u32())
                            } else {
                                None
                            }
                        })
                        .collect(),
                });
                if send_stats {
                    update.stats = Some(protos::sfu_to_device::Stats {
                        target_send_rate_kbps: Some(client.target_send_rate.as_kbps() as u32),
                        ideal_send_rate_kbps: Some(client.ideal_send_rate.as_kbps() as u32),
                        allocated_send_rate_kbps: Some(client.allocated_send_rate.as_kbps() as u32),
                    });
                }

                let mut update_rtp_payload: Vec<u8> = Vec::with_capacity(update.encoded_len());
                update
                    .encode(&mut update_rtp_payload)
                    .expect("Encode protobuf to client");

                let seqnum: rtp::FullSequenceNumber = client.next_server_to_client_data_rtp_seqnum;
                client.next_server_to_client_data_rtp_seqnum += 1;
                let timestamp = seqnum as rtp::TruncatedTimestamp;

                let update_rtp = rtp::Packet::with_empty_tag(
                    CLIENT_SERVER_DATA_PAYLOAD_TYPE,
                    seqnum,
                    timestamp,
                    CLIENT_SERVER_DATA_SSRC,
                    None,
                    &update_rtp_payload,
                );
                rtp_to_send.push((client.demux_id, update_rtp))
            }

            if send_stats {
                self.stats_update_sent = now;
            }
        }
    }

    fn calculate_active_speaker(&mut self, now: Instant) -> Option<DemuxId> {
        let first = self.clients.first()?;
        let mut most_active = self
            .active_speaker_ids
            .as_ref()
            .and_then(|(demux_id, _active_speaker_id)| self.find_client(*demux_id))
            .unwrap_or(first);

        for contender in &self.clients {
            if contender.demux_id != most_active.demux_id
                && contender
                    .incoming_audio_levels
                    .more_active_than_most_active(&most_active.incoming_audio_levels)
            {
                most_active = contender;
            }
        }

        let most_active_demux_id = most_active.demux_id;
        let most_active_ids = (most_active_demux_id, most_active.active_speaker_id.clone());
        if self.active_speaker_ids.as_ref() != Some(&most_active_ids) {
            self.find_client_mut(most_active_demux_id)
                .unwrap()
                .became_active_speaker = Some(now);
            self.active_speaker_ids = Some(most_active_ids);
            Some(most_active_demux_id)
        } else {
            None
        }
    }

    // All kinds of things can happen that trigger key frame requests to be needed:
    // - Video requests from clients
    // - Incoming bitrates changing
    // - Outgoing target bitrates changing
    // - Time passing
    // - Receivers sending key frame requests (PLIs)
    // Rather than try to catch all those cases, just call this occasionally.
    // Plus, key frame requests can be dropped, so we need to resend them occasionally.
    pub fn send_key_frame_requests_if_its_been_too_long(
        &mut self,
        now: Instant,
    ) -> Vec<(DemuxId, rtp::KeyFrameRequest)> {
        if now < self.key_frame_requests_sent + KEY_FRAME_REQUEST_CALCULATION_INTERVAL {
            // We sent key frame requests recently. Wait to resend/recalculate them.
            return vec![];
        }

        let mut desired_incoming_ssrcs: HashSet<rtp::Ssrc> = HashSet::new();
        for receiver in &mut self.clients {
            for video_forwarder in receiver.video_forwarder_by_sender_demux_id.values() {
                if let Some(desired_incoming_ssrc) = video_forwarder.needs_key_frame() {
                    desired_incoming_ssrcs.insert(desired_incoming_ssrc);
                }
            }
        }

        let key_frame_requests: Vec<(DemuxId, rtp::KeyFrameRequest)> = desired_incoming_ssrcs
            .into_iter()
            .filter_map(|desired_incoming_ssrc| {
                let sent = self
                    .key_frame_request_sent_by_ssrc
                    .get(&desired_incoming_ssrc)
                    .copied();
                let sent_recently =
                    sent.is_some() && now < (sent.unwrap() + KEY_FRAME_REQUEST_RESEND_INTERVAL);
                if sent_recently {
                    // If we sent a key frame for this SSRC recently, wait to resend one.
                    None
                } else {
                    Some((
                        DemuxId::from_ssrc(desired_incoming_ssrc),
                        rtp::KeyFrameRequest {
                            ssrc: desired_incoming_ssrc,
                        },
                    ))
                }
            })
            .collect();

        self.key_frame_requests_sent = now;
        key_frame_requests
    }

    /// Get the DemuxIds and "active speaker ID"s for each client.  These are needed for signaling.
    pub fn get_client_ids(&self) -> Vec<(DemuxId, String)> {
        self.clients
            .iter()
            .map(|client| (client.demux_id, client.active_speaker_id.clone()))
            .collect()
    }

    pub fn get_stats(&self) -> CallStats {
        CallStats {
            loggable_call_id: self.loggable_call_id.clone(),
            clients: self.clients.iter().map(Client::get_stats).collect(),
        }
    }
}

/// The per-client state
struct Client {
    // Immutable
    demux_id: DemuxId,
    user_id: UserId, // only used for stats
    active_speaker_id: String,
    resolution_request_id: u64,

    // Updated by incoming video packets
    incoming_video0: IncomingVideoState,
    incoming_video1: IncomingVideoState,
    incoming_video2: IncomingVideoState,

    // Updated by incoming audio packets
    incoming_audio_levels: audio::LevelsTracker,
    became_active_speaker: Option<Instant>,

    // Updated by incoming video requests
    video_request_proto: Option<protos::device_to_sfu::VideoRequestMessage>,
    requested_height_by_demux_id: HashMap<DemuxId, VideoHeight>,

    // Updated by Call::set_target_send_rate
    target_send_rate: DataRate,
    requested_max_send_rate: DataRate,
    send_rate_allocated: Instant,

    // Updated by send rate allocation, which is affected by
    // incoming video requests, target send rate,
    // incoming packets, and calls to tick().
    // requested_base_rate is the sum of the rates of the requested base layers.
    // Like ideal_send_rate, it's capped by max_requested_send_rate.
    requested_base_rate: DataRate,
    ideal_send_rate: DataRate,
    allocated_send_rate: DataRate,
    padding_send_rate: DataRate,

    // Updated by Call::update_padding_ssrc()
    padding_ssrc: Option<rtp::Ssrc>,

    // Updated by incoming video requests, target send rate,
    // incoming packets, and calls to tick().
    // Note: The following is n^2 memory usage
    // (where n is the number of clients in the group call).
    // So we need to be careful what we store here.
    audio_forwarder_by_sender_demux_id: HashMap<DemuxId, SingleSsrcRtpForwarder>,
    video_forwarder_by_sender_demux_id: HashMap<DemuxId, Vp8SimulcastRtpForwarder>,
    data_forwarder_by_sender_demux_id: HashMap<DemuxId, SingleSsrcRtpForwarder>,

    // Update with each proto send from server to client
    next_server_to_client_data_rtp_seqnum: rtp::FullSequenceNumber,
}

impl Client {
    fn new(
        demux_id: DemuxId,
        user_id: UserId,
        active_speaker_id: String,
        resolution_request_id: u64,
        requested_max_send_rate: DataRate,
        now: Instant,
    ) -> Self {
        Self {
            demux_id,
            user_id,
            active_speaker_id,
            resolution_request_id,

            incoming_video0: IncomingVideoState::default(),
            incoming_video1: IncomingVideoState::default(),
            incoming_video2: IncomingVideoState::default(),

            incoming_audio_levels: audio::LevelsTracker::default(),
            became_active_speaker: None,

            video_request_proto: None,
            requested_height_by_demux_id: HashMap::new(),

            target_send_rate: DataRate::default(),
            requested_max_send_rate,
            send_rate_allocated: now,

            requested_base_rate: DataRate::default(),
            ideal_send_rate: DataRate::default(),
            allocated_send_rate: DataRate::default(),
            padding_send_rate: DataRate::default(),

            padding_ssrc: None,

            audio_forwarder_by_sender_demux_id: HashMap::new(),
            video_forwarder_by_sender_demux_id: HashMap::new(),
            data_forwarder_by_sender_demux_id: HashMap::new(),

            next_server_to_client_data_rtp_seqnum: 1,
        }
    }

    fn parse_vp8_header_and_update_incoming_video_rate_and_resolution(
        &mut self,
        incoming_rtp: &rtp::Packet<&[u8]>,
        now: Instant,
    ) -> Option<vp8::ParsedHeader> {
        let incoming_vp8 = vp8::ParsedHeader::read(incoming_rtp.payload()).ok()?;
        let incoming_layer_id = LayerId::from_ssrc(incoming_rtp.ssrc());
        let incoming_video = match incoming_layer_id {
            Some(LayerId::Video0) => &mut self.incoming_video0,
            Some(LayerId::Video1) => &mut self.incoming_video1,
            Some(LayerId::Video2) => &mut self.incoming_video2,
            _ => {
                return None;
            }
        };

        incoming_video.rate_tracker.push(incoming_rtp.size(), now);
        let incoming_vp8_height = incoming_vp8
            .resolution
            .map(|res| VideoHeight::from(res.height));
        if incoming_vp8_height.is_some() && incoming_video.height != incoming_vp8_height {
            incoming_video.height = incoming_vp8_height;
            // Clear any higher resolutions.
            // This will be a little inefficient if we get a resolution change for layer 1 before
            // layer 0, but we can't really tell if resolutions between layers match or not.
            match incoming_layer_id {
                Some(LayerId::Video0) => {
                    self.incoming_video1.height = None;
                    self.incoming_video2.height = None;
                }
                Some(LayerId::Video1) => {
                    self.incoming_video2.height = None;
                }
                Some(LayerId::Video2) => {}
                _ => unreachable!("checked above"),
            }
        }
        Some(incoming_vp8)
    }

    fn forward_audio_rtp(
        &mut self,
        incoming_rtp: &rtp::Packet<&[u8]>,
    ) -> Option<rtp::Packet<Vec<u8>>> {
        let sender_demux_id = DemuxId::from_ssrc(incoming_rtp.ssrc());
        let forwarder = self
            .audio_forwarder_by_sender_demux_id
            .entry(sender_demux_id)
            .or_default();

        let outgoing_ssrc = incoming_rtp.ssrc();
        let outgoing_seqnum = forwarder.forward_rtp(incoming_rtp.seqnum())?;
        let outgoing_timestamp = incoming_rtp.timestamp;
        let outgoing_rtp = incoming_rtp.rewrite(outgoing_ssrc, outgoing_seqnum, outgoing_timestamp);
        Some(outgoing_rtp)
    }

    fn forward_video_rtp(
        &mut self,
        incoming_rtp: &rtp::Packet<&[u8]>,
        incoming_vp8: Option<&vp8::ParsedHeader>,
    ) -> Option<rtp::Packet<Vec<u8>>> {
        let incoming_vp8 = incoming_vp8?;

        let sender_demux_id = DemuxId::from_ssrc(incoming_rtp.ssrc());
        let forwarder = self
            .video_forwarder_by_sender_demux_id
            .get_mut(&sender_demux_id)?;

        let (outgoing_ssrc, outgoing) = forwarder.forward_vp8_rtp(incoming_rtp, incoming_vp8)?;
        let mut outgoing_rtp = incoming_rtp.rewrite(
            outgoing_ssrc,
            outgoing.seqnum,
            outgoing.timestamp as rtp::TruncatedTimestamp,
        );
        vp8::modify_header(
            outgoing_rtp.payload_mut(),
            outgoing.picture_id as vp8::TruncatedPictureId,
            outgoing.tl0_pic_idx as vp8::TruncatedTl0PicIdx,
        );
        Some(outgoing_rtp)
    }

    fn forward_data_rtp(
        &mut self,
        incoming_rtp: &rtp::Packet<&[u8]>,
    ) -> Option<rtp::Packet<Vec<u8>>> {
        let sender_demux_id = DemuxId::from_ssrc(incoming_rtp.ssrc());
        let forwarder = self
            .data_forwarder_by_sender_demux_id
            .entry(sender_demux_id)
            .or_default();
        let outgoing_ssrc = incoming_rtp.ssrc();
        let outgoing_seqnum = forwarder.forward_rtp(incoming_rtp.seqnum())?;
        let outgoing_timestamp = incoming_rtp.timestamp;
        let outgoing_rtp = incoming_rtp.rewrite(outgoing_ssrc, outgoing_seqnum, outgoing_timestamp);
        Some(outgoing_rtp)
    }

    fn get_stats(&self) -> ClientStats {
        ClientStats {
            demux_id: self.demux_id,
            user_id: self.user_id.clone(),
            video0_incoming_rate: self.incoming_video0.rate(),
            video1_incoming_rate: self.incoming_video1.rate(),
            video2_incoming_rate: self.incoming_video2.rate(),
            video0_incoming_height: self.incoming_video0.height,
            video1_incoming_height: self.incoming_video1.height,
            video2_incoming_height: self.incoming_video2.height,
            requested_base_rate: self.requested_base_rate,
            target_send_rate: self.target_send_rate,
            ideal_send_rate: self.ideal_send_rate,
            allocated_send_rate: self.allocated_send_rate,
            padding_send_rate: self.padding_send_rate,
            max_requested_height: self.requested_height_by_demux_id.values().max().copied(),
        }
    }
}

#[derive(Default)]
struct IncomingVideoState {
    rate_tracker: IncomingDataRateTracker,
    height: Option<VideoHeight>,
}

impl IncomingVideoState {
    pub fn rate(&self) -> Option<DataRate> {
        self.rate_tracker.rate()
    }

    fn as_allocatable_layer(&self) -> AllocatableVideoLayer {
        AllocatableVideoLayer {
            incoming_rate: self.rate().unwrap_or_default(),
            incoming_height: self.height.unwrap_or_default(),
        }
    }
}

#[derive(Default)]
pub struct IncomingDataRateTracker {
    // Oldest is at the back. The newest is at the front. This makes it easier
    // to do removal using VecDeque::split_off.
    history: VecDeque<(Instant, DataSize)>,
    accumulated_size: DataSize,
    rate: Option<DataRate>,
}

impl IncomingDataRateTracker {
    const MAX_DURATION: Duration = Duration::from_millis(5000);
    const MIN_DURATION: Duration = Duration::from_millis(500);

    fn rate(&self) -> Option<DataRate> {
        self.rate
    }

    /// Old values don't get pushed off unless update() is called periodically.
    fn push(&mut self, size: DataSize, time: Instant) {
        self.history.push_front((time, size));
        self.accumulated_size += size;
    }

    fn update(&mut self, now: Instant) {
        let deadline = now - Self::MAX_DURATION;
        let count_to_remove = self
            .history
            .iter()
            .rev()
            .take_while(|(old, _)| *old < deadline)
            .count();
        let removed = self.history.split_off(self.history.len() - count_to_remove);
        for (_, removed_size) in removed {
            self.accumulated_size -= removed_size;
        }

        let duration = if let Some((oldest, _)) = self.history.back() {
            now.saturating_duration_since(*oldest)
        } else {
            Duration::default()
        };
        self.rate = if duration >= Self::MIN_DURATION {
            Some(self.accumulated_size / duration)
        } else {
            // Wait for more info
            None
        }
    }
}

// This is spatial layers, not temporal layers
#[derive(Clone, Debug)]
struct AllocatableVideoLayer {
    incoming_rate: DataRate,
    incoming_height: VideoHeight,
}

#[derive(Clone, Debug)]
struct AllocatableVideo {
    sender_demux_id: DemuxId,
    // This is spatial layers, not temporal layers
    // lower index == lower resolution
    layers: [AllocatableVideoLayer; 3],
    requested_height: VideoHeight,
    // AKA became active speaker
    interesting: Option<Instant>,
}

#[derive(Clone, Debug, Eq, PartialEq)]
struct AllocatedVideo {
    sender_demux_id: DemuxId,
    layer_index: usize,
    // This is a convenience to include this.
    // It could be derived from AllocatedVideo + layer_index
    rate: DataRate,
}

fn ideal_video_layer_index(video: &AllocatableVideo) -> Option<usize> {
    let requested_height = video.requested_height;
    let has_rate = |layer: &AllocatableVideoLayer| layer.incoming_rate.as_bps() > 0;
    let has_height = |layer: &AllocatableVideoLayer| layer.incoming_height > VideoHeight::from(0);
    let has_height_and_rate = |layer: &AllocatableVideoLayer| has_rate(layer) && has_height(layer);
    let has_enough_height_and_rate = |layer: &AllocatableVideoLayer| {
        layer.incoming_height >= requested_height && has_rate(layer)
    };

    if requested_height == VideoHeight::from(0) {
        // Nothing was requested, so nothing is ideal.
        None
    } else if let Some(first_layer_which_has_enough) =
        video.layers.iter().position(has_enough_height_and_rate)
    {
        // It's possible for several layers to have the ideal height.
        // The ideal layer is the highest layer with the ideal height.
        let ideal_height = video.layers[first_layer_which_has_enough].incoming_height;
        video
            .layers
            .iter()
            .rposition(|layer: &AllocatableVideoLayer| {
                layer.incoming_height == ideal_height && has_rate(layer)
            })
    } else {
        // None of the layers have enough height and rate, so just take the
        // highest layer that has any height and rate.
        video.layers.iter().rposition(has_height_and_rate)
    }
}

fn ideal_send_rate(videos: &[AllocatableVideo], max_requested_send_rate: DataRate) -> DataRate {
    let allocatable: DataRate = videos
        .iter()
        .filter_map(|video| {
            let ideal_layer_index = ideal_video_layer_index(video)?;
            Some(video.layers[ideal_layer_index].incoming_rate)
        })
        .sum();
    min(allocatable, max_requested_send_rate)
}

fn base_video_layer_index(video: &AllocatableVideo) -> Option<usize> {
    if video.requested_height == VideoHeight::from(0) || video.layers[0].incoming_rate.as_bps() == 0
    {
        // Nothing was requested or the base layer doesn't have a rate
        None
    } else {
        Some(0)
    }
}

fn requested_base_rate(videos: &[AllocatableVideo], max_requested_send_rate: DataRate) -> DataRate {
    let allocatable: DataRate = videos
        .iter()
        .filter_map(|video| {
            let base_layer_index = base_video_layer_index(video)?;
            Some(video.layers[base_layer_index].incoming_rate)
        })
        .sum();
    min(allocatable, max_requested_send_rate)
}

fn allocate_send_rate(
    target_send_rate: DataRate,
    ideal_send_rate: DataRate,
    mut videos: Vec<AllocatableVideo>,
) -> HashMap<DemuxId, AllocatedVideo> {
    let allocatable_rate = min(target_send_rate, ideal_send_rate);
    let mut allocated_by_sender_demux_id: HashMap<DemuxId, AllocatedVideo> = HashMap::new();
    let mut allocated_rate = DataRate::default();

    // Biggest first and then (for the same size), most recently interesting first
    videos.sort_by_key(|video| std::cmp::Reverse((video.requested_height, video.interesting)));

    // We try to get the lowest layers for each one before trying to get the higher layer for any one.
    // In the future we may want to allow clients to prioritize a video to a degree
    // that it gets all of its layers first.
    for layer_index in 0..=2 {
        trace!("Allocating layer {}", layer_index);
        for video in &videos {
            let layer = &video.layers[layer_index];
            trace!(
                "Allocating {:?}.{} = ({}, {:?})",
                video.sender_demux_id,
                layer_index,
                layer.incoming_rate.as_kbps(),
                layer.incoming_height
            );
            if layer.incoming_height == VideoHeight::from(0) && layer.incoming_rate.as_bps() == 0 {
                trace!("Skipped layer with nothing coming in.");
                continue;
            }

            let ideal_layer_index = ideal_video_layer_index(video);
            if ideal_layer_index.is_none() || ideal_layer_index.unwrap() < layer_index {
                trace!(
                    "Skipped layer that's not requested (ideal layer index: {:?}).",
                    ideal_layer_index
                );
                continue;
            }

            let layer_rate = layer.incoming_rate;
            let lower_layer_rate = allocated_by_sender_demux_id
                .get(&video.sender_demux_id)
                .map(|allocated| allocated.rate)
                .unwrap_or_default();
            let rate_increase = layer_rate.saturating_sub(lower_layer_rate);
            let increased_allocated_rate = allocated_rate + rate_increase;
            if increased_allocated_rate > allocatable_rate {
                trace!(
                    "Skipped layer that's too big ({}/{} allocated and {}={}-{} increase)",
                    allocated_rate.as_kbps(),
                    allocatable_rate.as_kbps(),
                    rate_increase.as_kbps(),
                    layer_rate.as_kbps(),
                    lower_layer_rate.as_kbps()
                );
                continue;
            }

            allocated_by_sender_demux_id.insert(
                video.sender_demux_id,
                AllocatedVideo {
                    sender_demux_id: video.sender_demux_id,
                    layer_index,
                    rate: layer.incoming_rate,
                },
            );
            allocated_rate = increased_allocated_rate;
            trace!(
                "Allocated layer.  New allocated_rate: {:?}",
                allocated_rate.as_kbps()
            );
        }
    }

    allocated_by_sender_demux_id
}

// State to allow forwarding one SSRC to one SSRC.
// It's fairly simple, but it must deal with gaps
// in the seqnums and make sure to not reuse expanded seqnums.
// It does this by resetting an offset every time there is
// a gap that is too big to represent.
// This is similar to the VP8 simulcast forwarder
// when it gets a key frame.
#[derive(Default)]
struct SingleSsrcRtpForwarder {
    // When we "reset" due to a big gap (presumably of silence),
    // these are the first seqnums.
    // Knowing these allows us to adjust future packets so they
    // maintain the relative relationship that they did in the
    // unmodified stream of packets.
    // "first" here means "first since latest reset".
    first_incoming: rtp::FullSequenceNumber,
    first_outgoing: rtp::FullSequenceNumber,

    // We have to keep track of the max outgoing seqnums
    // to know what to make the "first" when we reset.
    // (generally, the max + 2).
    max_outgoing: rtp::FullSequenceNumber,
}

impl SingleSsrcRtpForwarder {
    fn forward_rtp(
        &mut self,
        incoming: rtp::FullSequenceNumber,
    ) -> Option<rtp::FullSequenceNumber> {
        const FULL_CYCLE: rtp::FullSequenceNumber =
            (rtp::TruncatedSequenceNumber::MAX as rtp::FullSequenceNumber) + 1;
        const HALF_CYCLE: rtp::FullSequenceNumber = FULL_CYCLE / 2;

        let mut outgoing = self
            .first_outgoing
            .checked_add(incoming.checked_sub(self.first_incoming)?)?;

        if outgoing > (self.max_outgoing + HALF_CYCLE - 1) {
            // The gap is too big.  Reset to a different offset.
            // Make sure to include a gap so the receiver knows there is some loss.
            outgoing = self.max_outgoing.checked_add(2)?;
            self.first_incoming = incoming;
            self.first_outgoing = outgoing;
            self.max_outgoing = outgoing;
        }

        self.max_outgoing = std::cmp::max(self.max_outgoing, outgoing);
        Some(outgoing)
    }
}

// State to allow forwarding a set of N video SSRCs as 1 video SSRC by
// changing the seqnums and VP8 picture IDs and VP8 TL0 Picture Indexes
// to make it appear that it's one stream rather than N.
struct Vp8SimulcastRtpForwarder {
    // The outgoing SSRC.  It never changes.
    outgoing_ssrc: rtp::Ssrc,
    forwarding: Vp8SimulcastRtpForwardingState,
    switching: Vp8SimulcastRtpSwitchingState,
    // We have to keep track of the max outgoing IDs
    // to know what to make the "first" when we switch.
    // (generally, the max + 1).  And we have to retain
    // that outside of the forwarding state below so we
    // retain it across various pause/forward cycles.
    max_outgoing: Vp8RewrittenIds,
}
enum Vp8SimulcastRtpSwitchingState {
    DoNotSwitch,
    SwitchAtNextKeyFrame(rtp::Ssrc),
}

enum Vp8SimulcastRtpForwardingState {
    Paused,
    Forwarding {
        incoming_ssrc: rtp::Ssrc,
        needs_key_frame: bool,

        // When we switch at a key frame, these are the first IDs.
        // Knowing these allows us to adjust future packets so they
        // maintain the relative relationship that they did in the
        // unmodified stream of packets.
        // "first" here means "first since latest switch".
        first_incoming: Vp8RewrittenIds,
        first_outgoing: Vp8RewrittenIds,

        // We have to keep track of the max incoming IDs
        // to be able to expand the IDs from truncated to full.
        // otherwise, rollover would mess up the "max outgoing"
        // below.
        max_incoming: Vp8RewrittenIds,
    },
}

// These are the IDs that we rewrite when forwarding VP8.
// These is a convenience for keep track of all 4 together,
// which is a common thing in Vp8SimulcastRtpForwarder.
#[derive(Default, Debug, Clone, Eq, PartialEq)]
struct Vp8RewrittenIds {
    seqnum: rtp::FullSequenceNumber,
    timestamp: rtp::FullTimestamp,
    picture_id: vp8::FullPictureId,
    tl0_pic_idx: vp8::FullTl0PicIdx,
}

impl Vp8RewrittenIds {
    fn new(
        seqnum: rtp::FullSequenceNumber,
        timestamp: rtp::FullTimestamp,
        picture_id: vp8::FullPictureId,
        tl0_pic_idx: vp8::FullTl0PicIdx,
    ) -> Self {
        Self {
            seqnum,
            timestamp,
            picture_id,
            tl0_pic_idx,
        }
    }

    fn checked_sub(&self, other: &Self) -> Option<Self> {
        Some(Self::new(
            self.seqnum.checked_sub(other.seqnum)?,
            self.timestamp.checked_sub(other.timestamp)?,
            self.picture_id.checked_sub(other.picture_id)?,
            self.tl0_pic_idx.checked_sub(other.tl0_pic_idx)?,
        ))
    }

    fn checked_add(&self, other: &Self) -> Option<Self> {
        Some(Self::new(
            self.seqnum.checked_add(other.seqnum)?,
            self.timestamp.checked_add(other.timestamp)?,
            self.picture_id.checked_add(other.picture_id)?,
            self.tl0_pic_idx.checked_add(other.tl0_pic_idx)?,
        ))
    }

    fn max(&self, other: &Self) -> Self {
        use std::cmp::max;
        Self::new(
            max(self.seqnum, other.seqnum),
            max(self.timestamp, other.timestamp),
            max(self.picture_id, other.picture_id),
            max(self.tl0_pic_idx, other.tl0_pic_idx),
        )
    }
}

impl Vp8SimulcastRtpForwarder {
    fn new(outgoing_ssrc: rtp::Ssrc) -> Self {
        Self {
            outgoing_ssrc,
            forwarding: Vp8SimulcastRtpForwardingState::Paused,
            switching: Vp8SimulcastRtpSwitchingState::DoNotSwitch,
            max_outgoing: Vp8RewrittenIds::default(),
        }
    }

    fn switching_ssrc(&self) -> Option<rtp::Ssrc> {
        if let Vp8SimulcastRtpSwitchingState::SwitchAtNextKeyFrame(switch_ssrc) = self.switching {
            Some(switch_ssrc)
        } else {
            None
        }
    }

    fn forwarding_ssrc(&self) -> Option<rtp::Ssrc> {
        if let Vp8SimulcastRtpForwardingState::Forwarding {
            incoming_ssrc: forward_ssrc,
            ..
        } = self.forwarding
        {
            Some(forward_ssrc)
        } else {
            None
        }
    }

    fn needs_key_frame(&self) -> Option<rtp::Ssrc> {
        if let Vp8SimulcastRtpSwitchingState::SwitchAtNextKeyFrame(switching_ssrc) = self.switching
        {
            Some(switching_ssrc)
        } else if let Vp8SimulcastRtpForwardingState::Forwarding {
            incoming_ssrc: forwarding_ssrc,
            needs_key_frame: true,
            ..
        } = self.forwarding
        {
            Some(forwarding_ssrc)
        } else {
            None
        }
    }

    // If the SSRC is set to None, don't forward anything.
    fn set_desired_ssrc(&mut self, desired_incoming_ssrc: Option<rtp::Ssrc>) {
        if let Some(desired_incoming_ssrc) = desired_incoming_ssrc {
            if self.forwarding_ssrc() != Some(desired_incoming_ssrc)
                && self.switching_ssrc() != Some(desired_incoming_ssrc)
            {
                trace!(
                    "Begin forwarding from SSRC {} to SSRC {} once we receive a key frame.",
                    desired_incoming_ssrc,
                    self.outgoing_ssrc
                );
                self.switching =
                    Vp8SimulcastRtpSwitchingState::SwitchAtNextKeyFrame(desired_incoming_ssrc);
            }
        } else {
            if self.forwarding_ssrc().is_some() {
                trace!("Stop forwarding to SSRC {}", self.outgoing_ssrc);
            }

            self.forwarding = Vp8SimulcastRtpForwardingState::Paused;
            self.switching = Vp8SimulcastRtpSwitchingState::DoNotSwitch;
        }
    }

    // Set this when the receiving clients sends a key frame request for the sender.
    fn set_needs_key_frame(&mut self) {
        // Don't pause because packets arriving out of order would not get delivered
        // and we'd perhaps need to request a new key frame yet again.
        // Plus, pausing messes up the congestion controller.
        if let Vp8SimulcastRtpForwardingState::Forwarding {
            needs_key_frame, ..
        } = &mut self.forwarding
        {
            *needs_key_frame = true;
        }
    }

    // Selects a new seqnum, VP8 Picture ID, and VP8 Tl0PicIdx.  If None is returned, that means
    // don't forward the packet.
    fn forward_vp8_rtp(
        &mut self,
        incoming_rtp: &rtp::Packet<&[u8]>,
        incoming_vp8: &vp8::ParsedHeader,
    ) -> Option<(rtp::Ssrc, Vp8RewrittenIds)> {
        let incoming_picture_id = incoming_vp8.picture_id?;
        let incoming_tl0_pic_idx = incoming_vp8.tl0_pic_idx?;

        if self.switching_ssrc() == Some(incoming_rtp.ssrc()) && incoming_vp8.is_key_frame {
            trace!(
                "Begin forwarding from SSRC {} to SSRC {} because we have a key frame.",
                incoming_rtp.ssrc(),
                self.outgoing_ssrc
            );

            let first_incoming = Vp8RewrittenIds::new(
                incoming_rtp.seqnum(),
                // These are OK to expand without one of the expand_X functions because
                // they are only used as a base for future values.
                // In other words, we are only tracking the ROC since the switching point,
                // and that is now, so the ROC is 0.
                incoming_rtp.timestamp as rtp::FullTimestamp,
                incoming_picture_id as vp8::FullPictureId,
                incoming_tl0_pic_idx as vp8::FullTl0PicIdx,
            );
            // We make two simplifying assumptions here:
            // 1. The first packet we received is the first packet of the key frame.
            // If this is false (due to reordering), the receiving client will have to
            // ask for a new key frame.  That should hopefully be infrequent.
            // 2. The last packet we forwarded (of the previous layer) is the last packet we'd ever want to forward.
            // If this is false, the last frame of the previous layer will be dropped by the receiving client.
            // Which hopefully will not be noticeable.
            // These assumptions allow us to have no gap between the last seqnum before the switch
            // and the first seqnum/picture_id after the switch and doesn't require any fancy logic or queuing.
            // Ok, there is a gap of 1 seqnum to signify to the encoder that the
            // previous frame was (probably) incomplete.  That's why there's a 2 for the seqnum.
            let first_outgoing = self
                .max_outgoing
                .checked_add(&Vp8RewrittenIds::new(2, 1, 1, 1))?;

            self.forwarding = Vp8SimulcastRtpForwardingState::Forwarding {
                incoming_ssrc: incoming_rtp.ssrc(),
                first_incoming: first_incoming.clone(),
                first_outgoing: first_outgoing.clone(),
                max_incoming: first_incoming,
                needs_key_frame: false,
            };
            self.switching = Vp8SimulcastRtpSwitchingState::DoNotSwitch;
            self.max_outgoing = first_outgoing;
        }

        if let Vp8SimulcastRtpForwardingState::Forwarding {
            incoming_ssrc,
            first_incoming,
            first_outgoing,
            max_incoming,
            needs_key_frame,
            ..
        } = &mut self.forwarding
        {
            if *incoming_ssrc == incoming_rtp.ssrc() {
                let incoming = Vp8RewrittenIds::new(
                    incoming_rtp.seqnum(),
                    rtp::expand_timestamp(incoming_rtp.timestamp, &mut max_incoming.timestamp),
                    vp8::expand_picture_id(incoming_picture_id, &mut max_incoming.picture_id),
                    vp8::expand_tl0_pic_idx(incoming_tl0_pic_idx, &mut max_incoming.tl0_pic_idx),
                );
                // If the sub fails, it's because the incoming packet predates the switch (before the key frame)
                let outgoing =
                    first_outgoing.checked_add(&incoming.checked_sub(first_incoming)?)?;
                self.max_outgoing = self.max_outgoing.max(&outgoing);

                if incoming_vp8.is_key_frame {
                    *needs_key_frame = false;
                }
                trace!(
                    "Forward packet from SSRC {} to SSRC {} while rewriting IDs from {:?} to {:?}",
                    incoming_rtp.ssrc(),
                    self.outgoing_ssrc,
                    incoming,
                    outgoing
                );
                Some((self.outgoing_ssrc, outgoing))
            } else {
                // Forwarding a different SSRC
                None
            }
        } else {
            // Not forwarding at all
            None
        }
    }
}

pub struct CallStats {
    pub loggable_call_id: LoggableCallId,
    pub clients: Vec<ClientStats>,
}

pub struct ClientStats {
    pub demux_id: DemuxId,
    pub user_id: UserId,
    pub video0_incoming_rate: Option<DataRate>,
    pub video1_incoming_rate: Option<DataRate>,
    pub video2_incoming_rate: Option<DataRate>,
    pub video0_incoming_height: Option<VideoHeight>,
    pub video1_incoming_height: Option<VideoHeight>,
    pub video2_incoming_height: Option<VideoHeight>,
    pub target_send_rate: DataRate,
    pub requested_base_rate: DataRate,
    pub ideal_send_rate: DataRate,
    pub allocated_send_rate: DataRate,
    pub padding_send_rate: DataRate,
    pub max_requested_height: Option<VideoHeight>,
}

#[cfg(test)]
mod loggable_call_id_tests {
    use hex_literal::hex;

    use super::*;

    #[test]
    fn display_call_id_16_long() {
        let bytes = hex!("000102030405060708090a0b0c0d0e0f");
        let call_id: LoggableCallId = bytes[..].into();

        assert_eq!("000102", format!("{}", call_id));
        assert_eq!("000102", call_id.to_string());
    }

    #[test]
    fn display_call_id_64_long() {
        let bytes = hex!("000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f222122232425262728292a2b2c2d2e2f033132333435363738393a3b3c3d3e3f");
        let call_id: LoggableCallId = bytes[..].into();

        assert_eq!("000102", format!("{}", call_id));
        assert_eq!("000102", call_id.to_string());
    }

    #[test]
    fn display_empty_call_id() {
        let bytes = [];
        let call_id: LoggableCallId = bytes[..].into();

        assert_eq!("<EMPTY>", format!("{}", call_id));
    }

    #[test]
    fn display_short_call_id_4_bytes() {
        let bytes = hex!("0c0d0e0f");
        let call_id: LoggableCallId = bytes[..].into();

        assert_eq!("0c0d0e", format!("{}", call_id));
    }

    #[test]
    fn display_short_call_id_3_bytes() {
        let bytes = hex!("0d0e0f");
        let call_id: LoggableCallId = bytes[..].into();

        assert_eq!("0d0e0f", format!("{}", call_id));
    }

    #[test]
    fn display_short_call_id_2_bytes() {
        let bytes = hex!("0e0f");
        let call_id: LoggableCallId = bytes[..].into();

        assert_eq!("0e0f", format!("{}", call_id));
    }

    #[test]
    fn display_short_call_id_1_byte() {
        let bytes = hex!("0f");
        let call_id: LoggableCallId = bytes[..].into();

        assert_eq!("0f", format!("{}", call_id));
    }
}

#[cfg(test)]
mod call_tests {
    use super::*;
    use crate::common::PixelSize;

    #[test]
    fn test_rate_tracker() {
        let now = Instant::now();
        let at = |millis| now + Duration::from_millis(millis);

        let mut tracker = IncomingDataRateTracker::default();
        assert_eq!(None, tracker.rate());

        tracker.push(DataSize::from_bits(1000), at(0));
        tracker.update(at(1));
        // We get ignore values until 500ms have passed
        assert_eq!(None, tracker.rate());

        tracker.update(at(500));
        assert_eq!(Some(DataRate::from_bps(2000)), tracker.rate());

        tracker.push(DataSize::from_bits(1000), at(500));
        tracker.push(DataSize::from_bits(1000), at(1000));
        tracker.update(at(1000));
        assert_eq!(Some(DataRate::from_bps(3000)), tracker.rate());

        for i in 2..100 {
            tracker.push(DataSize::from_bits(1000), at(i * 1000));
        }
        tracker.update(at(100000));
        assert_eq!(Some(DataRate::from_bps(1000)), tracker.rate());
    }

    #[test]
    fn test_forward_audio() {
        let full = (rtp::TruncatedSequenceNumber::MAX as rtp::FullSequenceNumber) + 1;
        let half = full / 2;
        let expand = |full: rtp::FullSequenceNumber, max: &mut rtp::FullSequenceNumber| {
            rtp::expand_seqnum(full as rtp::TruncatedSequenceNumber, max)
        };

        let mut forwarder = SingleSsrcRtpForwarder::default();
        let mut receiver_max = 0;
        let mut used_seqnums = std::collections::HashSet::new();
        for range in vec![1..half, full..(2 * full)] {
            for seqnum_in in range {
                let seqnum_out = forwarder.forward_rtp(seqnum_in).unwrap();
                // Make sure we never reuse a seqnum
                let not_reused = used_seqnums.insert(seqnum_out);
                assert!(not_reused, "Reused seqnum {}", seqnum_out);
                // Make sure the receiver can always keep track of the ROC
                assert_eq!(seqnum_out, expand(seqnum_out, &mut receiver_max));
            }
        }
        // Don't try to send anything from before the gap.
        for seqnum_in in 1..half {
            assert_eq!(None, forwarder.forward_rtp(seqnum_in));
        }

        // Do try and send things out of order
        let seqnum_out = forwarder.forward_rtp(2 * full + 5).unwrap();
        assert_eq!(Some(seqnum_out - 1), forwarder.forward_rtp(2 * full + 4));
        assert_eq!(Some(seqnum_out - 2), forwarder.forward_rtp(2 * full + 3));
        assert_eq!(Some(seqnum_out - 3), forwarder.forward_rtp(2 * full + 2));
    }

    #[test]
    fn test_forward_vp8() {
        // This is a convenience struct to make the tests more readable.
        #[derive(Clone)]
        struct Incoming {
            ssrc: u32,
            index: u32,
            rtp: rtp::Packet<Vec<u8>>,
            vp8: vp8::ParsedHeader,
        }

        impl Incoming {
            fn start_with_key_frame(ssrc: u32, width: u16, height: u16) -> Self {
                let index = 1;
                let is_key_frame = true;
                Self::new(ssrc, index, is_key_frame, Some(PixelSize { width, height }))
            }

            fn increment_without_key_frame(&self) -> Self {
                let is_key_frame = false;
                let resolution = None;
                Self::new(self.rtp.ssrc(), self.index + 1, is_key_frame, resolution)
            }

            fn increment_with_key_frame(&self) -> Self {
                let is_key_frame = true;
                Self::new(
                    self.rtp.ssrc(),
                    self.index + 1,
                    is_key_frame,
                    self.vp8.resolution,
                )
            }

            fn new(
                ssrc: u32,
                index: u32,
                is_key_frame: bool,
                resolution: Option<PixelSize>,
            ) -> Self {
                let pt = 108;
                let seqnum = ((ssrc * 10000) + index) as u64;
                let timestamp = (ssrc * 100000) + (index * 30000); // 30 fps at 90khz clock
                Self {
                    ssrc,
                    index,
                    rtp: rtp::Packet::with_empty_tag(pt, seqnum, timestamp, ssrc, None, &[]),
                    vp8: vp8::ParsedHeader {
                        picture_id: Some(((1000 * ssrc) + index) as u16),
                        tl0_pic_idx: Some(((100 * ssrc) + index) as u8),
                        is_key_frame,
                        resolution,
                    },
                }
            }

            fn skip_to(
                &self,
                seqnum: rtp::FullSequenceNumber,
                timestamp: rtp::TruncatedTimestamp,
                picture_id: vp8::TruncatedPictureId,
                tl0_pic_idx: vp8::TruncatedTl0PicIdx,
            ) -> Self {
                let mut rtp = self.rtp.clone();
                rtp.set_seqnum_in_header(seqnum);
                rtp.set_timestamp_in_header(timestamp);
                Self {
                    rtp,
                    vp8: vp8::ParsedHeader {
                        picture_id: Some(picture_id),
                        tl0_pic_idx: Some(tl0_pic_idx),
                        ..self.vp8.clone()
                    },
                    ..self.clone()
                }
            }

            fn forward(
                &self,
                forwarder: &mut Vp8SimulcastRtpForwarder,
            ) -> Option<(rtp::Ssrc, Vp8RewrittenIds)> {
                forwarder.forward_vp8_rtp(&self.rtp.borrow(), &self.vp8)
            }
        }

        let outgoing_ssrc = 99;

        // This is a convenience function to make the test more readable.
        let outgoing = |seqnum: rtp::FullSequenceNumber,
                        timestamp: rtp::FullTimestamp,
                        picture_id: vp8::FullPictureId,
                        tl0_pic_idx: vp8::FullTl0PicIdx|
         -> Option<(rtp::Ssrc, Vp8RewrittenIds)> {
            Some((
                outgoing_ssrc,
                Vp8RewrittenIds {
                    seqnum,
                    timestamp,
                    picture_id,
                    tl0_pic_idx,
                },
            ))
        };

        let mut forwarder = Vp8SimulcastRtpForwarder::new(outgoing_ssrc);

        // Nothing desired yet.  Don't send key frame requests and don't forward packets.
        let layer0 = Incoming::start_with_key_frame(0, 320, 180);
        assert_eq!(None, forwarder.needs_key_frame());
        assert_eq!(None, layer0.forward(&mut forwarder));

        // Layer 0 desired.  Send key frame requests and forward a key frame and subsequent packets.
        forwarder.set_desired_ssrc(Some(layer0.ssrc));
        assert_eq!(Some(layer0.ssrc), forwarder.needs_key_frame());
        assert_eq!(outgoing(2, 1, 1, 1), layer0.forward(&mut forwarder));
        let layer0 = layer0.increment_without_key_frame();
        assert_eq!(outgoing(3, 30001, 2, 2), layer0.forward(&mut forwarder));

        let layer1 = Incoming::start_with_key_frame(1, 640, 360);
        let layer1_original = layer1.clone();
        let layer2 = Incoming::start_with_key_frame(2, 1280, 720);
        // But don't forward packets from other layers
        assert_eq!(None, layer1.forward(&mut forwarder));
        assert_eq!(None, layer2.forward(&mut forwarder));

        // If nothing is desired again, don't send key frame requests and don't forward packets.
        forwarder.set_desired_ssrc(None);
        assert_eq!(None, forwarder.needs_key_frame());
        assert_eq!(
            None,
            layer0.increment_with_key_frame().forward(&mut forwarder)
        );
        assert_eq!(None, layer0.forward(&mut forwarder));

        // Once desired again, forward again once we have key frames
        forwarder.set_desired_ssrc(Some(layer0.ssrc));
        assert_eq!(Some(layer0.ssrc), forwarder.needs_key_frame());
        let layer0 = layer0.increment_without_key_frame();
        assert_eq!(None, layer0.forward(&mut forwarder));
        let layer0 = layer0.increment_with_key_frame();
        // There is a gap in the sequence number on purpose to indicate the last frame of the previous
        // layer wasn't finished.
        assert_eq!(outgoing(5, 30002, 3, 3), layer0.forward(&mut forwarder));

        // We no longer need a key frame
        assert_eq!(None, forwarder.needs_key_frame());
        let layer0 = layer0.increment_without_key_frame();
        assert_eq!(outgoing(6, 60002, 4, 4), layer0.forward(&mut forwarder));

        // Request a switch to a higher layer
        // Continue to forward the existing layer until a key frame comes.
        forwarder.set_desired_ssrc(Some(layer1.ssrc));
        let layer0 = layer0.increment_without_key_frame();
        assert_eq!(outgoing(7, 90002, 5, 5), layer0.forward(&mut forwarder));
        let layer1 = layer1.increment_without_key_frame();
        assert_eq!(None, layer1.forward(&mut forwarder));
        let layer2 = layer2.increment_without_key_frame();
        assert_eq!(None, layer2.forward(&mut forwarder));

        // Once we get a key frame, switch
        let layer1 = layer1.increment_with_key_frame();
        assert_eq!(outgoing(9, 90003, 6, 6), layer1.forward(&mut forwarder));
        assert_eq!(None, forwarder.needs_key_frame());
        let layer0 = layer0.increment_with_key_frame();
        assert_eq!(None, layer0.forward(&mut forwarder));
        let layer2 = layer2.increment_with_key_frame();
        assert_eq!(None, layer2.forward(&mut forwarder));

        // Don't forward old packets from the new layer.
        // Such a packet would be prior to the key frame, which means it
        // can't be decoded.
        assert_eq!(None, layer1_original.forward(&mut forwarder));

        // Request another layer
        // Continue to forward the existing layer until a key frame comes.
        forwarder.set_desired_ssrc(Some(layer2.ssrc));
        assert_eq!(Some(layer2.ssrc), forwarder.needs_key_frame());
        let layer0 = layer0.increment_with_key_frame();
        assert_eq!(None, layer0.forward(&mut forwarder));
        let layer1 = layer1.increment_without_key_frame();
        assert_eq!(outgoing(10, 120003, 7, 7), layer1.forward(&mut forwarder));
        let layer2 = layer2.increment_without_key_frame();
        assert_eq!(None, layer2.forward(&mut forwarder));

        let layer2 = layer2.increment_with_key_frame();
        assert_eq!(outgoing(12, 120004, 8, 8), layer2.forward(&mut forwarder));
        let layer0 = layer0.increment_with_key_frame();
        assert_eq!(None, layer0.forward(&mut forwarder));
        let layer1 = layer1.increment_with_key_frame();
        assert_eq!(None, layer1.forward(&mut forwarder));

        // Now go back to layer0
        forwarder.set_desired_ssrc(Some(layer0.ssrc));
        assert_eq!(Some(layer0.ssrc), forwarder.needs_key_frame());
        let layer0 = layer0.increment_without_key_frame();
        assert_eq!(None, layer0.forward(&mut forwarder));
        let layer1 = layer1.increment_with_key_frame();
        assert_eq!(None, layer1.forward(&mut forwarder));
        let layer2 = layer2.increment_without_key_frame();
        assert_eq!(outgoing(13, 150004, 9, 9), layer2.forward(&mut forwarder));

        let layer0 = layer0.increment_with_key_frame();
        assert_eq!(outgoing(15, 150005, 10, 10), layer0.forward(&mut forwarder));
        let layer1 = layer1.increment_with_key_frame();
        assert_eq!(None, layer1.forward(&mut forwarder));
        let layer2 = layer2.increment_with_key_frame();
        assert_eq!(None, layer2.forward(&mut forwarder));

        // If something goes wrong with this layer, keep forwarding it
        // but request a key frame until we get one.
        forwarder.set_needs_key_frame();
        assert_eq!(Some(layer0.ssrc), forwarder.needs_key_frame());
        let layer0 = layer0.increment_with_key_frame();
        assert_eq!(outgoing(16, 180005, 11, 11), layer0.forward(&mut forwarder));
        assert_eq!(None, forwarder.needs_key_frame());

        // Unless we desire a higher layer, then request that instead.
        forwarder.set_needs_key_frame();
        assert_eq!(Some(layer0.ssrc), forwarder.needs_key_frame());
        forwarder.set_desired_ssrc(Some(layer1.ssrc));
        assert_eq!(Some(layer1.ssrc), forwarder.needs_key_frame());

        // Also forward packets even if they're out of order
        let layer0a = layer0.increment_without_key_frame();
        let layer0b = layer0a.increment_without_key_frame();
        assert_eq!(
            outgoing(18, 240005, 13, 13),
            layer0b.forward(&mut forwarder)
        );
        assert_eq!(
            outgoing(17, 210005, 12, 12),
            layer0a.forward(&mut forwarder)
        );

        // And deal with roll over properly (pretend there's a long gap of no forwarding)
        forwarder.set_desired_ssrc(None);
        assert_eq!(None, forwarder.needs_key_frame());
        assert_eq!(None, layer0.forward(&mut forwarder));
        assert_eq!(None, layer1.forward(&mut forwarder));
        assert_eq!(None, layer2.forward(&mut forwarder));

        forwarder.set_desired_ssrc(Some(layer0.ssrc));
        let max_seqnum = u16::MAX as u64;
        let max_timestamp = u32::MAX;
        let max_picture_id = u16::MAX / 2;
        let max_tl0_pic_idx = u8::MAX;
        let layer0_before_rollover = layer0.increment_with_key_frame().skip_to(
            max_seqnum,
            max_timestamp,
            max_picture_id,
            max_tl0_pic_idx,
        );
        let layer0_after_rollover = layer0.skip_to(max_seqnum + 1, 0, 0, 0);
        assert_eq!(
            outgoing(20, 240006, 14, 14),
            layer0_before_rollover.forward(&mut forwarder)
        );
        assert_eq!(
            outgoing(21, 240007, 15, 15),
            layer0_after_rollover.forward(&mut forwarder)
        );
    }

    #[test]
    fn test_allocate_send_rate() {
        // Convenience methods to make test more readable
        fn layer(incoming_rate_kbps: u64, incoming_height: VideoHeight) -> AllocatableVideoLayer {
            AllocatableVideoLayer {
                incoming_rate: DataRate::from_kbps(incoming_rate_kbps),
                incoming_height,
            }
        }

        fn video(
            sender_demux_id: DemuxId,
            layers: [&AllocatableVideoLayer; 3],
        ) -> AllocatableVideo {
            AllocatableVideo {
                sender_demux_id,
                layers: [layers[0].clone(), layers[1].clone(), layers[2].clone()],
                requested_height: VideoHeight::from(0),
                interesting: None,
            }
        }

        fn request(requested_height: VideoHeight, video: &AllocatableVideo) -> AllocatableVideo {
            let mut video: AllocatableVideo = video.clone();
            video.requested_height = requested_height;
            video
        }

        fn interesting(secs_ago: u64, video: &AllocatableVideo) -> AllocatableVideo {
            let mut video: AllocatableVideo = video.clone();
            video.interesting = Some(Instant::now() - Duration::from_secs(secs_ago));
            video
        }

        fn allocate(
            target_send_rate_kbps: u64,
            videos: &[&AllocatableVideo],
            max_requested_send_rate_kbps: u64,
        ) -> (u64, Vec<(u32, usize, u64)>) {
            let videos: Vec<AllocatableVideo> = videos.iter().copied().cloned().collect();
            let target_send_rate = DataRate::from_kbps(target_send_rate_kbps);
            let max_requested_send_rate = DataRate::from_kbps(max_requested_send_rate_kbps);
            let ideal_send_rate = ideal_send_rate(&videos, max_requested_send_rate);
            let mut allocated: Vec<_> =
                allocate_send_rate(target_send_rate, ideal_send_rate, videos)
                    .iter()
                    .map(|(demux_id, allocated)| {
                        (
                            u32::from(*demux_id),
                            allocated.layer_index,
                            allocated.rate.as_kbps(),
                        )
                    })
                    .collect();
            allocated.sort_unstable();
            (ideal_send_rate.as_kbps(), allocated)
        }

        let nothing = layer(0, VideoHeight::from(0));
        let layer0 = layer(200, VideoHeight::from(180));
        let layer1 = layer(800, VideoHeight::from(360));
        let layer2 = layer(2000, VideoHeight::from(720));
        let dropped = layer(0, VideoHeight::from(1080));
        let video0 = video(DemuxId(0), [&nothing, &nothing, &nothing]);
        let video1 = video(DemuxId(1), [&layer0, &dropped, &nothing]);
        let video2 = video(DemuxId(2), [&layer0, &layer1, &nothing]);
        let video3 = video(DemuxId(3), [&layer0, &layer1, &layer2]);
        let video4 = video(DemuxId(4), [&layer0, &layer1, &layer2]);
        let no_max = 100000;

        // Can't send and nothing to receive
        assert_eq!((0, vec![]), allocate(0, &[], no_max));

        // Can send but nothing to receive
        assert_eq!((0, vec![]), allocate(1000, &[], no_max));
        assert_eq!((0, vec![]), allocate(1000, &[&video0], no_max));

        // Can send and receive but nothing requested.
        assert_eq!((0, vec![]), allocate(1000, &[&video1], no_max));

        // Can receive and requested, but nothing to send.
        assert_eq!(
            (200, vec![]),
            allocate(0, &[&request(VideoHeight::from(1080), &video1)], no_max)
        );

        // Finally can send, receive, and have requested
        assert_eq!(
            (200, vec![(1, 0, 200)]),
            allocate(1000, &[&request(VideoHeight::from(1080), &video1)], no_max)
        );

        // Verify we fill lower layers first, starting with highest resolution requested.
        assert_eq!(
            (3000, vec![(3, 0, 200)]),
            allocate(
                200,
                &[
                    &request(VideoHeight::from(180), &video1),
                    &request(VideoHeight::from(360), &video2),
                    &request(VideoHeight::from(720), &video3)
                ],
                no_max
            )
        );
        assert_eq!(
            (3000, vec![(2, 0, 200), (3, 0, 200)]),
            allocate(
                400,
                &[
                    &request(VideoHeight::from(180), &video1),
                    &request(VideoHeight::from(360), &video2),
                    &request(VideoHeight::from(720), &video3)
                ],
                no_max
            )
        );
        assert_eq!(
            (3000, vec![(1, 0, 200), (2, 0, 200), (3, 0, 200)]),
            allocate(
                600,
                &[
                    &request(VideoHeight::from(180), &video1),
                    &request(VideoHeight::from(360), &video2),
                    &request(VideoHeight::from(720), &video3)
                ],
                no_max
            )
        );
        assert_eq!(
            (3000, vec![(1, 0, 200), (2, 0, 200), (3, 1, 800)]),
            allocate(
                1200,
                &[
                    &request(VideoHeight::from(180), &video1),
                    &request(VideoHeight::from(360), &video2),
                    &request(VideoHeight::from(720), &video3)
                ],
                no_max
            )
        );
        assert_eq!(
            (3000, vec![(1, 0, 200), (2, 1, 800), (3, 1, 800)]),
            allocate(
                1800,
                &[
                    &request(VideoHeight::from(180), &video1),
                    &request(VideoHeight::from(360), &video2),
                    &request(VideoHeight::from(720), &video3)
                ],
                no_max
            )
        );
        assert_eq!(
            (3000, vec![(1, 0, 200), (2, 1, 800), (3, 2, 2000)]),
            allocate(
                3000,
                &[
                    &request(VideoHeight::from(180), &video1),
                    &request(VideoHeight::from(360), &video2),
                    &request(VideoHeight::from(720), &video3)
                ],
                no_max
            )
        );

        // We ignore higher bitrates available if we request a max
        assert_eq!(
            (1200, vec![(1, 0, 200), (2, 0, 200), (3, 1, 800)]),
            allocate(
                3000,
                &[
                    &request(VideoHeight::from(180), &video1),
                    &request(VideoHeight::from(360), &video2),
                    &request(VideoHeight::from(720), &video3)
                ],
                1200
            )
        );

        // If we have extra, nothing changes.
        assert_eq!(
            (3000, vec![(1, 0, 200), (2, 1, 800), (3, 2, 2000)]),
            allocate(
                5000,
                &[
                    &request(VideoHeight::from(1080), &video1),
                    &request(VideoHeight::from(1081), &video2),
                    &request(VideoHeight::from(1082), &video3)
                ],
                no_max
            )
        );

        // If we request less, things drop off, including the ideal rate
        assert_eq!(
            (600, vec![(1, 0, 200), (2, 0, 200), (3, 0, 200)]),
            allocate(
                5000,
                &[
                    &request(VideoHeight::from(1), &video1),
                    &request(VideoHeight::from(2), &video2),
                    &request(VideoHeight::from(3), &video3)
                ],
                no_max
            )
        );

        // If all requests are the same, the interest time determines fill order
        assert_eq!(
            (3000, vec![(1, 0, 200)]),
            allocate(
                200,
                &[
                    &request(VideoHeight::from(1080), &interesting(1, &video1)),
                    &request(VideoHeight::from(1080), &interesting(2, &video2)),
                    &request(VideoHeight::from(1080), &interesting(3, &video3)),
                ],
                no_max
            )
        );
        assert_eq!(
            (3000, vec![(1, 0, 200), (2, 0, 200)]),
            allocate(
                400,
                &[
                    &request(VideoHeight::from(1080), &interesting(1, &video1)),
                    &request(VideoHeight::from(1080), &interesting(2, &video2)),
                    &request(VideoHeight::from(1080), &interesting(3, &video3)),
                ],
                no_max
            )
        );
        assert_eq!(
            (5000, vec![(1, 0, 200), (2, 0, 200), (4, 0, 200)]),
            allocate(
                600,
                &[
                    &request(VideoHeight::from(1080), &interesting(1, &video1)),
                    &request(VideoHeight::from(1080), &interesting(2, &video2)),
                    &request(VideoHeight::from(1080), &interesting(3, &video4)),
                    &request(VideoHeight::from(1080), &interesting(4, &video3)),
                ],
                no_max
            )
        );
        assert_eq!(
            (
                5000,
                vec![(1, 0, 200), (2, 0, 200), (3, 0, 200), (4, 0, 200)]
            ),
            allocate(
                800,
                &[
                    &request(VideoHeight::from(1080), &interesting(1, &video1)),
                    &request(VideoHeight::from(1080), &interesting(2, &video2)),
                    &request(VideoHeight::from(1080), &interesting(3, &video4)),
                    &request(VideoHeight::from(1080), &interesting(4, &video3)),
                ],
                no_max
            )
        );
        assert_eq!(
            (4000, vec![(3, 0, 200), (4, 1, 800)]),
            allocate(
                1000,
                &[
                    &request(VideoHeight::from(1080), &interesting(3, &video4)),
                    &request(VideoHeight::from(1080), &interesting(4, &video3)),
                ],
                no_max
            )
        );
        assert_eq!(
            (4000, vec![(3, 1, 800), (4, 2, 2000)]),
            allocate(
                2800,
                &[
                    &request(VideoHeight::from(1080), &interesting(3, &video4)),
                    &request(VideoHeight::from(1080), &interesting(4, &video3)),
                ],
                no_max
            )
        );
        assert_eq!(
            (4000, vec![(3, 2, 2000), (4, 2, 2000)]),
            allocate(
                10000,
                &[
                    &request(VideoHeight::from(1080), &interesting(3, &video4)),
                    &request(VideoHeight::from(1080), &interesting(4, &video3)),
                ],
                no_max
            )
        );

        // And make sure interest doesn't override resolution
        assert_eq!(
            (600, vec![(3, 0, 200)]),
            allocate(
                200,
                &[
                    &request(VideoHeight::from(1), &interesting(1, &video1)),
                    &request(VideoHeight::from(2), &interesting(2, &video2)),
                    &request(VideoHeight::from(3), &interesting(3, &video3)),
                ],
                no_max
            )
        );
        assert_eq!(
            (600, vec![(2, 0, 200), (3, 0, 200)]),
            allocate(
                400,
                &[
                    &request(VideoHeight::from(1), &interesting(1, &video1)),
                    &request(VideoHeight::from(2), &interesting(2, &video2)),
                    &request(VideoHeight::from(3), &interesting(3, &video3)),
                ],
                no_max
            )
        );
        assert_eq!(
            (600, vec![(1, 0, 200), (2, 0, 200), (3, 0, 200)]),
            allocate(
                600,
                &[
                    &request(VideoHeight::from(1), &interesting(1, &video1)),
                    &request(VideoHeight::from(2), &interesting(2, &video2)),
                    &request(VideoHeight::from(3), &interesting(3, &video3)),
                ],
                no_max
            )
        );

        let screenshare_layer0 = layer(100, VideoHeight::from(1080));
        let screenshare_layer1 = layer(1500, VideoHeight::from(1080));
        let screenshare_layer2 = layer(0, VideoHeight::from(1080));
        let screenshare = video(
            DemuxId(4),
            [
                &screenshare_layer0,
                &screenshare_layer1,
                &screenshare_layer2,
            ],
        );

        assert_eq!(
            (0, vec![]),
            allocate(
                2000,
                &[&request(VideoHeight::from(0), &screenshare),],
                no_max
            )
        );
        assert_eq!(
            (1500, vec![(4, 0, 100)]),
            allocate(
                600,
                &[&request(VideoHeight::from(1), &screenshare),],
                no_max
            )
        );
        assert_eq!(
            (1500, vec![(4, 1, 1500)]),
            allocate(
                2000,
                &[&request(VideoHeight::from(1), &screenshare),],
                no_max
            )
        );
    }

    fn create_call(call_id: &[u8], now: Instant, system_now: SystemTime) -> Call {
        let creator_id = UserId::from(b"creator_id".to_vec());
        let active_speaker_message_interval = Duration::from_secs(1);
        let initial_target_send_rate = DataRate::from_kbps(600);
        let default_requested_max_send_rate = DataRate::from_kbps(20000);
        Call::new(
            LoggableCallId::from(call_id),
            creator_id,
            active_speaker_message_interval,
            initial_target_send_rate,
            default_requested_max_send_rate,
            now,
            system_now,
        )
    }

    fn demux_id_from_unshifted(demux_id_without_shifting: u32) -> DemuxId {
        DemuxId::from_ssrc(demux_id_without_shifting << 4)
    }

    fn add_client(
        call: &mut Call,
        user_id: &str,
        demux_id_without_shifting: u32,
        now: Instant,
    ) -> DemuxId {
        let demux_id = demux_id_from_unshifted(demux_id_without_shifting);
        let user_id = UserId::from(user_id.as_bytes().to_vec());
        let active_speaker_id = format!("{}_active_speaker_id", demux_id_without_shifting);
        let resolution_request_id = 10_000_000_000u64 + (demux_id_without_shifting as u64);
        call.add_client(
            demux_id,
            user_id,
            active_speaker_id,
            resolution_request_id,
            now,
        );
        demux_id
    }

    fn create_rtp(
        sender_demux_id: DemuxId,
        layer_id: LayerId,
        seqnum: rtp::FullSequenceNumber,
        payload: &[u8],
    ) -> rtp::Packet<Vec<u8>> {
        let ssrc = layer_id.to_ssrc(sender_demux_id);
        use LayerId::*;
        let pt = match layer_id {
            RtpData => 101,
            Audio => 102,
            Video0 | Video1 | Video2 => 108,
        };
        let timestamp = seqnum as rtp::TruncatedTimestamp;
        // This only gets filled in by the Connection.
        let tcc_seqnum = None;
        rtp::Packet::with_empty_tag(pt, seqnum, timestamp, ssrc, tcc_seqnum, payload)
    }

    fn create_data_rtp(
        sender_demux_id: DemuxId,
        seqnum: rtp::FullSequenceNumber,
    ) -> rtp::Packet<Vec<u8>> {
        let layer_id = LayerId::RtpData;
        // The SFU doesn't look at it anyway
        let payload = seqnum.to_be_bytes();
        create_rtp(sender_demux_id, layer_id, seqnum, &payload[..])
    }

    fn create_audio_rtp(
        sender_demux_id: DemuxId,
        seqnum: rtp::FullSequenceNumber,
    ) -> rtp::Packet<Vec<u8>> {
        let layer_id = LayerId::Audio;
        // The SFU doesn't look at it anyway
        let payload = seqnum.to_be_bytes();
        create_rtp(sender_demux_id, layer_id, seqnum, &payload[..])
    }

    fn create_video_rtp(
        sender_demux_id: DemuxId,
        layer_id: LayerId,
        picture_id: u16,
        tl0_pic_idx: u8,
        seqnum: rtp::FullSequenceNumber,
        key_frame_size: Option<PixelSize>,
    ) -> rtp::Packet<Vec<u8>> {
        // Simulate big video packets
        let mut payload = vec![0; 1200];
        write_vp8_header(picture_id, tl0_pic_idx, key_frame_size, &mut payload);
        create_rtp(sender_demux_id, layer_id, seqnum, &payload[..])
    }

    fn write_vp8_header(
        picture_id: u16,
        tl0_pic_idx: u8,
        key_frame_size: Option<PixelSize>,
        payload: &mut [u8],
    ) {
        // We always have extensions (for picture ID, etc)
        let x_bit = 1u8 << 7;
        // N bit is 0, but it doesn't matter.
        let s_bit = (key_frame_size.is_some() as u8) << 4;
        // Partition ID is 0, which it must be for a key frame.  It doesn't matter for other frames.
        payload[0] = x_bit | s_bit;

        // We always have a picture ID.
        let i_bit = 1u8 << 7;
        // We always have a TL0 PIC IDX.
        let l_bit = 1u8 << 6;
        // We won't include the TID or key_idx (T bit and K bit).
        payload[1] = i_bit | l_bit;

        // We always use 15-bit picture IDs
        payload[2..4].copy_from_slice(&((picture_id | 0b1000_0000_0000_0000).to_be_bytes()));
        payload[4] = tl0_pic_idx;

        if let Some(PixelSize { width, height }) = key_frame_size {
            // The P bit is 0, which means "this is a key frame".
            payload[5] = 0;
            // 5 bytes are ignored by the SFU.
            // It just wants the width and height.
            payload[11..13].copy_from_slice(&(width & 0b11_1111_1111_1111).to_le_bytes());
            payload[13..15].copy_from_slice(&(height & 0b11_1111_1111_1111).to_le_bytes());
        }
    }

    fn create_server_to_client_rtp(
        seqnum: rtp::FullSequenceNumber,
        payload: &[u8],
    ) -> rtp::Packet<Vec<u8>> {
        let ssrc = 1;
        let pt = 101;
        let tcc_seqnum = None;
        let timestamp = seqnum as rtp::TruncatedTimestamp;
        rtp::Packet::with_empty_tag(pt, seqnum, timestamp, ssrc, tcc_seqnum, payload)
    }

    fn create_sfu_to_device(
        joined_or_left: bool,
        active_speaker_ids: Option<(&str, DemuxId)>,
        all_demux_ids: &[DemuxId],
    ) -> protos::SfuToDevice {
        protos::SfuToDevice {
            device_joined_or_left: if joined_or_left {
                Some(protos::sfu_to_device::DeviceJoinedOrLeft::default())
            } else {
                None
            },
            speaker: active_speaker_ids.map(|(device_id, demux_id)| {
                protos::sfu_to_device::Speaker {
                    long_device_id: Some(device_id.to_owned()),
                    demux_id: Some(demux_id.as_u32()),
                }
            }),
            current_devices: Some(protos::sfu_to_device::CurrentDevices {
                demux_ids_with_video: vec![],
                all_demux_ids: all_demux_ids.iter().map(|id| id.as_u32()).collect(),
            }),
            ..Default::default()
        }
    }

    #[derive(Clone, Copy, PartialEq, Eq, Debug)]
    enum IdentifiedBy {
        DeviceId,
        DemuxId,
        Both,
    }

    fn create_resolution_request_rtp(
        demux_id_without_shifting: u32,
        height: u16,
        identified_by: IdentifiedBy,
    ) -> rtp::Packet<Vec<u8>> {
        use protos::device_to_sfu::video_request_message::VideoRequest;
        let request = match identified_by {
            IdentifiedBy::DeviceId => VideoRequest {
                short_device_id: Some(10_000_000_000 + (demux_id_without_shifting as u64)),
                height: Some(height as u32),
                demux_id: None,
            },
            IdentifiedBy::DemuxId => VideoRequest {
                short_device_id: None,
                height: Some(height as u32),
                demux_id: Some(demux_id_from_unshifted(demux_id_without_shifting).as_u32()),
            },
            IdentifiedBy::Both => VideoRequest {
                short_device_id: Some(10_000_000_000 + (demux_id_without_shifting as u64)),
                height: Some(height as u32),
                demux_id: Some(demux_id_from_unshifted(demux_id_without_shifting).as_u32()),
            },
        };

        create_server_to_client_rtp(
            1,
            encode_proto(protos::DeviceToSfu {
                video_request: Some(protos::device_to_sfu::VideoRequestMessage {
                    requests: vec![request],
                    ..Default::default()
                }),
                ..Default::default()
            })
            .as_slice(),
        )
    }

    fn create_max_receive_rate_request(max_receive_rate: DataRate) -> rtp::Packet<Vec<u8>> {
        create_server_to_client_rtp(
            1,
            encode_proto(protos::DeviceToSfu {
                video_request: Some(protos::device_to_sfu::VideoRequestMessage {
                    max_kbps: Some(max_receive_rate.as_kbps() as u32),
                    ..Default::default()
                }),
                ..Default::default()
            })
            .as_slice(),
        )
    }

    fn create_leave_rtp() -> rtp::Packet<Vec<u8>> {
        create_server_to_client_rtp(
            1,
            encode_proto(protos::DeviceToSfu {
                leave: Some(protos::device_to_sfu::LeaveMessage {}),
                ..Default::default()
            })
            .as_slice(),
        )
    }

    fn encode_proto(message: impl Message) -> Vec<u8> {
        let mut encoded = Vec::with_capacity(message.encoded_len());
        message.encode(&mut encoded).unwrap();
        encoded
    }

    #[test]
    fn forward_heartbeats() {
        let now = Instant::now();
        let system_now = SystemTime::now();

        let mut call = create_call(b"call_id", now, system_now);

        let sender_demux_id = demux_id_from_unshifted(1);
        let mut rtp1 = create_data_rtp(sender_demux_id, 1);
        assert_eq!(
            Err(Error::UnknownDemuxId(sender_demux_id)),
            call.handle_rtp(sender_demux_id, rtp1.borrow_mut(), now)
        );

        let sender_demux_id = add_client(&mut call, "sender", 1, now);
        // It's authorized, but there aren't any receivers to send to.
        let rtp_to_send = call
            .handle_rtp(sender_demux_id, rtp1.borrow_mut(), now)
            .unwrap();
        assert_eq!(0, rtp_to_send.len());

        let receiver1_demux_id = add_client(&mut call, "receiver1", 2, now);
        let receiver2_demux_id = add_client(&mut call, "receiver2", 3, now);
        let rtp_to_send = call
            .handle_rtp(sender_demux_id, rtp1.borrow_mut(), now)
            .unwrap();
        assert_eq!(
            vec![
                (receiver1_demux_id, rtp1.clone()),
                (receiver2_demux_id, rtp1.clone())
            ],
            rtp_to_send
        );

        let mut rtp2 = create_data_rtp(sender_demux_id, 2);
        assert_eq!(
            Err(Error::UnauthorizedRtpSsrc(
                sender_demux_id,
                receiver2_demux_id
            )),
            call.handle_rtp(receiver2_demux_id, rtp1.borrow_mut(), now)
        );
        let rtp_to_send = call
            .handle_rtp(sender_demux_id, rtp2.borrow_mut(), now)
            .unwrap();
        assert_eq!(
            vec![
                (receiver1_demux_id, rtp2.clone()),
                (receiver2_demux_id, rtp2)
            ],
            rtp_to_send
        );
    }

    #[test]
    fn forward_audio() {
        let now = Instant::now();
        let system_now = SystemTime::now();

        let mut call = create_call(b"call_id", now, system_now);

        let sender_demux_id = demux_id_from_unshifted(1);
        let mut rtp1 = create_audio_rtp(sender_demux_id, 1);
        assert_eq!(
            Err(Error::UnknownDemuxId(sender_demux_id)),
            call.handle_rtp(sender_demux_id, rtp1.borrow_mut(), now)
        );

        let sender_demux_id = add_client(&mut call, "sender", 1, now);
        // It's authorized, but there aren't any receivers to send to.
        let rtp_to_send = call
            .handle_rtp(sender_demux_id, rtp1.borrow_mut(), now)
            .unwrap();
        assert_eq!(0, rtp_to_send.len());

        let receiver1_demux_id = add_client(&mut call, "receiver1", 2, now);
        let receiver2_demux_id = add_client(&mut call, "receiver2", 3, now);
        let rtp_to_send = call
            .handle_rtp(sender_demux_id, rtp1.borrow_mut(), now)
            .unwrap();
        assert_eq!(
            vec![
                (receiver1_demux_id, rtp1.clone()),
                (receiver2_demux_id, rtp1.clone())
            ],
            rtp_to_send
        );

        let mut rtp2 = create_audio_rtp(sender_demux_id, 2);
        assert_eq!(
            Err(Error::UnauthorizedRtpSsrc(
                sender_demux_id,
                receiver2_demux_id
            )),
            call.handle_rtp(receiver2_demux_id, rtp1.borrow_mut(), now)
        );
        let rtp_to_send = call
            .handle_rtp(sender_demux_id, rtp2.borrow_mut(), now)
            .unwrap();
        assert_eq!(
            vec![
                (receiver1_demux_id, rtp2.clone()),
                (receiver2_demux_id, rtp2)
            ],
            rtp_to_send
        );

        let mut rtp3 = create_audio_rtp(sender_demux_id, 3);
        // Don't forward silence
        rtp3.audio_level = Some(0);
        let rtp_to_send = call
            .handle_rtp(sender_demux_id, rtp3.borrow_mut(), now)
            .unwrap();
        assert_eq!(0, rtp_to_send.len());

        let mut rtp4 = create_audio_rtp(sender_demux_id, 4);
        rtp4.audio_level = Some(50);
        let rtp_to_send = call
            .handle_rtp(sender_demux_id, rtp4.borrow_mut(), now)
            .unwrap();
        assert_eq!(
            vec![
                (receiver1_demux_id, rtp4.clone()),
                (receiver2_demux_id, rtp4)
            ],
            rtp_to_send
        );

        let mut rtp5 = create_audio_rtp(sender_demux_id, 4);
        rtp5.audio_level = Some(10);
        let rtp_to_send = call
            .handle_rtp(sender_demux_id, rtp5.borrow_mut(), now)
            .unwrap();
        assert_eq!(
            vec![
                (receiver1_demux_id, rtp5.clone()),
                (receiver2_demux_id, rtp5)
            ],
            rtp_to_send
        );
    }

    fn forward_video_by_identifier(identifier: IdentifiedBy) {
        let now = Instant::now();
        let system_now = SystemTime::now();
        let at = |millis| now + Duration::from_millis(millis);

        let mut call = create_call(b"call_id", now, system_now);

        let sender_demux_id = demux_id_from_unshifted(1);
        let mut picture_id = 101;
        let mut tl0_pic_idx = 11;
        let mut seqnum = 1;
        let size = PixelSize {
            width: 320,
            height: 240,
        };
        let mut rtp = create_video_rtp(
            sender_demux_id,
            LayerId::Video0,
            picture_id,
            tl0_pic_idx,
            seqnum,
            Some(size),
        );
        assert_eq!(
            Err(Error::UnknownDemuxId(sender_demux_id)),
            call.handle_rtp(sender_demux_id, rtp.borrow_mut(), now)
        );

        let sender_demux_id = add_client(&mut call, "sender", 1, now);
        // It's authorized, but there aren't any receivers to send to.
        let rtp_to_send = call
            .handle_rtp(sender_demux_id, rtp.borrow_mut(), at(1))
            .unwrap();
        assert_eq!(0, rtp_to_send.len());

        // We need at least 2 packets to get the incoming rate working.
        seqnum += 1;
        let mut rtp = create_video_rtp(
            sender_demux_id,
            LayerId::Video0,
            picture_id,
            tl0_pic_idx,
            seqnum,
            Some(size),
        );
        let rtp_to_send = call
            .handle_rtp(sender_demux_id, rtp.borrow_mut(), at(2))
            .unwrap();
        assert_eq!(0, rtp_to_send.len());

        // This is required to update the incoming rate.
        // We don't trust the incoming rate for 500ms.
        call.tick(at(501));
        assert_eq!(
            Some(DataRate::from_bps(39296)),
            call.clients[0].incoming_video0.rate()
        );
        assert_eq!(
            Some(VideoHeight::from(size.height)),
            call.clients[0].incoming_video0.height
        );

        let receiver1_demux_id = add_client(&mut call, "receiver1", 2, at(502));
        let receiver2_demux_id = add_client(&mut call, "receiver2", 3, at(503));

        picture_id += 1;
        tl0_pic_idx += 1;
        seqnum += 1;
        // Note: This is not a key frame, so it's not forwarded right away
        let mut rtp = create_video_rtp(
            sender_demux_id,
            LayerId::Video0,
            picture_id,
            tl0_pic_idx,
            seqnum,
            None,
        );
        let rtp_to_send = call
            .handle_rtp(sender_demux_id, rtp.borrow_mut(), at(504))
            .unwrap();
        assert_eq!(0, rtp_to_send.len());

        // Need at least 5ms since last tick to generate key frames
        let expected_key_frame_request = (
            sender_demux_id,
            rtp::KeyFrameRequest {
                ssrc: LayerId::Video0.to_ssrc(sender_demux_id),
            },
        );
        let (_rtp_to_send, outgoing_key_frame_requests) = call.tick(at(506));
        assert_eq!(
            vec![expected_key_frame_request],
            outgoing_key_frame_requests
        );

        // Still not a key frame.  Keep ignoring.
        seqnum += 1;
        let mut rtp = create_video_rtp(
            sender_demux_id,
            LayerId::Video0,
            picture_id,
            tl0_pic_idx,
            seqnum,
            None,
        );
        let rtp_to_send = call
            .handle_rtp(sender_demux_id, rtp.borrow_mut(), at(505))
            .unwrap();
        assert_eq!(0, rtp_to_send.len());

        // And keep asking for a key frame
        let (_rtp_to_send, outgoing_key_frame_requests) = call.tick(at(707));
        assert_eq!(
            vec![expected_key_frame_request],
            outgoing_key_frame_requests
        );

        // Now we get a key frame we can forward
        picture_id += 1;
        tl0_pic_idx += 1;
        seqnum += 1;
        let mut rtp = create_video_rtp(
            sender_demux_id,
            LayerId::Video0,
            picture_id,
            tl0_pic_idx,
            seqnum,
            Some(size),
        );
        let rtp_to_send = call
            .handle_rtp(sender_demux_id, rtp.borrow_mut(), at(708))
            .unwrap();

        let rewritten_picture_id = 1;
        let rewritten_tl0_pic_idx = 1;
        let rewritten_timestamp = 1;
        let rewritten_seqnum = 2;
        let mut rewritten_rtp = create_video_rtp(
            sender_demux_id,
            LayerId::Video0,
            rewritten_picture_id,
            rewritten_tl0_pic_idx,
            rewritten_timestamp,
            Some(size),
        );
        rewritten_rtp.set_seqnum_in_header(rewritten_seqnum);
        assert_eq!(
            vec![
                (receiver1_demux_id, rewritten_rtp.clone()),
                (receiver2_demux_id, rewritten_rtp),
            ],
            rtp_to_send
        );

        // And we don't ask for a key frame any more
        let (_rtp_to_send, outgoing_key_frame_requests) = call.tick(at(908));
        assert_eq!(0, outgoing_key_frame_requests.len());

        // Unless the client requests one
        call.handle_key_frame_requests(
            receiver1_demux_id,
            &[expected_key_frame_request.1],
            at(908),
        );
        let (_rtp_to_send, outgoing_key_frame_requests) = call.tick(at(1110));
        assert_eq!(
            vec![expected_key_frame_request],
            outgoing_key_frame_requests
        );

        // Get the sender sending a higher layer
        let mut picture_id_layer1 = 201;
        let mut tl0_pic_idx_layer1 = 21;
        let mut seqnum_layer1 = 0;
        let size_layer1 = PixelSize {
            width: 640,
            height: 480,
        };
        // We need at least 3 packets to get the incoming rate working above the lower layer.
        for _ in 0..3 {
            seqnum_layer1 += 1;
            let mut rtp_layer1 = create_video_rtp(
                sender_demux_id,
                LayerId::Video1,
                picture_id_layer1,
                tl0_pic_idx_layer1,
                seqnum_layer1,
                Some(size_layer1),
            );
            let rtp_to_send = call
                .handle_rtp(sender_demux_id, rtp_layer1.borrow_mut(), at(2000))
                .unwrap();
            // No one has requested it yet
            assert_eq!(0, rtp_to_send.len());
        }

        // This is required to update the incoming rate.
        // We don't trust the incoming rate for 500ms.
        call.tick(at(2500));
        assert_eq!(
            Some(DataRate::from_bps(58944)),
            call.clients[0].incoming_video1.rate()
        );
        assert_eq!(
            Some(VideoHeight::from(size_layer1.height)),
            call.clients[0].incoming_video1.height
        );

        let mut resolution_request = create_resolution_request_rtp(1, 480, identifier);

        // When a receiver requests a resolution high enough for layer1, it triggers key frame request for that layer,
        call.handle_rtp(
            receiver1_demux_id,
            resolution_request.borrow_mut(),
            at(2801),
        )
        .unwrap();
        let (_rtp_to_send, outgoing_key_frame_requests) = call.tick(at(2801));
        let expected_key_frame_request_layer1 = (
            sender_demux_id,
            rtp::KeyFrameRequest {
                ssrc: LayerId::Video1.to_ssrc(sender_demux_id),
            },
        );
        assert_eq!(
            Some(expected_key_frame_request_layer1.1.ssrc),
            call.clients[1]
                .video_forwarder_by_sender_demux_id
                .get(&sender_demux_id)
                .unwrap()
                .needs_key_frame()
        );
        assert_eq!(
            vec![expected_key_frame_request_layer1],
            outgoing_key_frame_requests
        );

        // But the lower layer is still forwarded until a key frame for the higher layer comes in.
        picture_id += 1;
        tl0_pic_idx += 1;
        seqnum += 1;
        let mut rtp = create_video_rtp(
            sender_demux_id,
            LayerId::Video0,
            picture_id,
            tl0_pic_idx,
            seqnum,
            Some(size),
        );
        let rtp_to_send = call
            .handle_rtp(sender_demux_id, rtp.borrow_mut(), at(2802))
            .unwrap();

        let rewritten_picture_id = 2;
        let rewritten_tl0_pic_idx = 2;
        let rewritten_timestamp = 2;
        let rewritten_seqnum = 3;
        let mut rewritten_rtp = create_video_rtp(
            sender_demux_id,
            LayerId::Video0,
            rewritten_picture_id,
            rewritten_tl0_pic_idx,
            rewritten_timestamp,
            Some(size),
        );
        rewritten_rtp.set_seqnum_in_header(rewritten_seqnum);
        assert_eq!(
            vec![
                (receiver1_demux_id, rewritten_rtp.clone()),
                (receiver2_demux_id, rewritten_rtp),
            ],
            rtp_to_send
        );

        picture_id_layer1 += 1;
        tl0_pic_idx_layer1 += 1;
        let mut rtp_layer1 = create_video_rtp(
            sender_demux_id,
            LayerId::Video1,
            picture_id_layer1,
            tl0_pic_idx_layer1,
            seqnum_layer1,
            Some(size_layer1),
        );
        let rtp_to_send = call
            .handle_rtp(sender_demux_id, rtp_layer1.borrow_mut(), at(2803))
            .unwrap();
        let rewritten_picture_id = 3;
        let rewritten_tl0_pic_idx = 3;
        let rewritten_timestamp = 3;
        let rewritten_seqnum = 5;
        let mut rewritten_rtp = create_video_rtp(
            sender_demux_id,
            LayerId::Video0,
            rewritten_picture_id,
            rewritten_tl0_pic_idx,
            rewritten_timestamp,
            Some(size_layer1),
        );
        rewritten_rtp.set_seqnum_in_header(rewritten_seqnum);
        assert_eq!(vec![(receiver1_demux_id, rewritten_rtp),], rtp_to_send);

        // If the incoming bitrate rate gets higher than the target send rate, drop back to the base layer
        for _ in 0..200 {
            seqnum_layer1 += 1;
            let mut rtp_layer1 = create_video_rtp(
                sender_demux_id,
                LayerId::Video1,
                picture_id_layer1,
                tl0_pic_idx_layer1,
                seqnum_layer1,
                Some(size_layer1),
            );
            call.handle_rtp(sender_demux_id, rtp_layer1.borrow_mut(), at(4000))
                .unwrap();
        }
        let (_rtp_to_send, outgoing_key_frame_requests) = call.tick(at(4000));
        assert_eq!(
            Some(DataRate::from_bps(1002048)),
            call.clients[0].incoming_video1.rate()
        );
        assert_eq!(
            Some(expected_key_frame_request.1.ssrc),
            call.clients[1]
                .video_forwarder_by_sender_demux_id
                .get(&sender_demux_id)
                .unwrap()
                .needs_key_frame()
        );
        assert_eq!(
            vec![expected_key_frame_request],
            outgoing_key_frame_requests
        );

        assert_eq!(
            vec![
                SendRateAllocationInfo {
                    demux_id: sender_demux_id,
                    padding_send_rate: DataRate::default(),
                    padding_ssrc: Some(LayerId::Video0.to_rtx_ssrc(receiver1_demux_id)),
                    requested_base_rate: DataRate::default(),
                    ideal_send_rate: DataRate::from_bps(0),
                },
                SendRateAllocationInfo {
                    demux_id: receiver1_demux_id,
                    padding_send_rate: DataRate::from_bps(585261),
                    padding_ssrc: Some(LayerId::Video0.to_rtx_ssrc(sender_demux_id)),
                    requested_base_rate: DataRate::from_bps(14739),
                    ideal_send_rate: DataRate::from_bps(1002048),
                },
                SendRateAllocationInfo {
                    demux_id: receiver2_demux_id,
                    padding_send_rate: DataRate::default(),
                    padding_ssrc: Some(LayerId::Video0.to_rtx_ssrc(sender_demux_id)),
                    requested_base_rate: DataRate::from_bps(14739),
                    ideal_send_rate: DataRate::from_bps(14739),
                }
            ],
            call.get_send_rate_allocation_info().collect::<Vec<_>>()
        );
    }

    #[test]
    fn forward_video() {
        forward_video_by_identifier(IdentifiedBy::DeviceId);
        forward_video_by_identifier(IdentifiedBy::DemuxId);
        forward_video_by_identifier(IdentifiedBy::Both);
    }

    #[test]
    fn send_updates_when_someone_joins_or_leaves() {
        let now = Instant::now();
        let system_now = SystemTime::now();
        let at = |millis| now + Duration::from_millis(millis);

        let mut call = create_call(b"call_id", now, system_now);

        // It's a little weird that you get updates for when you join, but it doesn't really do any harm and it's much easier to implement.
        let demux_id1 = add_client(&mut call, "1", 1, at(99));

        let expected_update_payload_just_client1 = encode_proto(create_sfu_to_device(
            true,
            Some(("1_active_speaker_id", demux_id1)),
            &[demux_id1],
        ));

        let (rtp_to_send, _outgoing_key_frame_requests) = call.tick(at(100));
        assert_eq!(
            vec![(
                demux_id1,
                create_server_to_client_rtp(1, &expected_update_payload_just_client1)
            )],
            rtp_to_send
        );

        let demux_id2 = add_client(&mut call, "2", 2, at(200));

        let expected_update_payload_both_clients = encode_proto(create_sfu_to_device(
            true,
            Some(("1_active_speaker_id", demux_id1)),
            &[demux_id1, demux_id2],
        ));

        let (rtp_to_send, _outgoing_key_frame_requests) = call.tick(at(200));
        assert_eq!(
            vec![
                (
                    demux_id1,
                    create_server_to_client_rtp(2, &expected_update_payload_both_clients)
                ),
                (
                    demux_id2,
                    create_server_to_client_rtp(1, &expected_update_payload_both_clients)
                )
            ],
            rtp_to_send
        );

        // Nothing is sent out because nothing changed.
        let (rtp_to_send, _outgoing_key_frame_requests) = call.tick(at(300));
        assert_eq!(0, rtp_to_send.len());

        call.remove_client(demux_id1, at(400));

        let expected_update_payload_just_client2 = encode_proto(create_sfu_to_device(
            true,
            Some(("1_active_speaker_id", demux_id1)), // Is it okay that the active speaker left?
            &[demux_id2],
        ));

        let (rtp_to_send, _outgoing_key_frame_requests) = call.tick(at(400));
        assert_eq!(
            vec![(
                demux_id2,
                create_server_to_client_rtp(2, &expected_update_payload_just_client2)
            )],
            rtp_to_send
        );
    }

    #[test]
    fn send_active_speaker_updates() {
        let now = Instant::now();
        let system_now = SystemTime::now();
        let at = |millis| now + Duration::from_millis(millis);

        let mut call = create_call(b"call_id", now, system_now);
        let demux_id1 = add_client(&mut call, "1", 1, at(1));
        let demux_id2 = add_client(&mut call, "2", 2, at(2));
        // If there is no audio activity from anyone, we choose the first client as the active speaker
        let (rtp_to_send, _outgoing_key_frame_requests) = call.tick(at(301));

        let active_speaker_id = "1_active_speaker_id";
        let expected_update_payload = encode_proto(create_sfu_to_device(
            true,
            Some((active_speaker_id, demux_id1)),
            &[demux_id1, demux_id2],
        ));
        assert_eq!(
            Some((demux_id1, active_speaker_id.to_owned())),
            call.active_speaker_ids
        );
        assert_eq!(
            vec![
                (
                    demux_id1,
                    create_server_to_client_rtp(1, &expected_update_payload)
                ),
                (
                    demux_id2,
                    create_server_to_client_rtp(1, &expected_update_payload)
                )
            ],
            rtp_to_send
        );

        // Switch to demux_id2 as active speaker and send out an update.
        for seqnum in 1..100 {
            let mut rtp = create_audio_rtp(demux_id2, seqnum);
            // We can't just send 100 every time or that becomes the noise floor
            rtp.audio_level = Some(seqnum as u8);
            let _rtp_to_send = call.handle_rtp(demux_id2, rtp.borrow_mut(), at(301 + seqnum));
        }
        let (rtp_to_send, _outgoing_key_frame_requests) = call.tick(at(602));

        let active_speaker_id = "2_active_speaker_id";
        let expected_update_payload = encode_proto(create_sfu_to_device(
            false,
            Some((active_speaker_id, demux_id2)),
            &[demux_id1, demux_id2],
        ));
        assert_eq!(
            Some((demux_id2, active_speaker_id.to_owned())),
            call.active_speaker_ids
        );
        assert_eq!(
            vec![
                (
                    demux_id1,
                    create_server_to_client_rtp(2, &expected_update_payload)
                ),
                (
                    demux_id2,
                    create_server_to_client_rtp(2, &expected_update_payload)
                )
            ],
            rtp_to_send
        );

        // Switch to demux_id1 as active speaker and send out an update.
        for seqnum in 1..100 {
            let mut rtp = create_audio_rtp(demux_id1, seqnum);
            // We can't just send 100 every time or that becomes the noise floor
            rtp.audio_level = Some(seqnum as u8);
            let _rtp_to_send = call.handle_rtp(demux_id1, rtp.borrow_mut(), at(602 + seqnum));

            let mut rtp = create_audio_rtp(demux_id2, seqnum);
            rtp.audio_level = Some(0);
            let _rtp_to_send = call.handle_rtp(demux_id2, rtp.borrow_mut(), at(602 + seqnum));
        }
        let (rtp_to_send, _outgoing_key_frame_requests) = call.tick(at(903));

        let active_speaker_id = "1_active_speaker_id";
        let expected_update_payload = encode_proto(create_sfu_to_device(
            false,
            Some((active_speaker_id, demux_id1)),
            &[demux_id1, demux_id2],
        ));
        assert_eq!(
            Some((demux_id1, active_speaker_id.to_owned())),
            call.active_speaker_ids
        );
        assert_eq!(
            vec![
                (
                    demux_id1,
                    create_server_to_client_rtp(3, &expected_update_payload)
                ),
                (
                    demux_id2,
                    create_server_to_client_rtp(3, &expected_update_payload)
                )
            ],
            rtp_to_send
        );

        let get_stats = |from_server: &[RtpToSend],
                         receiver_demux_id: DemuxId|
         -> Option<protos::sfu_to_device::Stats> {
            let (_demux_id, rtp) = from_server
                .iter()
                .find(|(demux_id, _rtp)| *demux_id == receiver_demux_id)?;
            let proto = protos::SfuToDevice::decode(rtp.payload()).ok()?;
            proto.stats
        };

        // Don't resend anything after just 301ms (except stats)
        let (rtp_to_send, _outgoing_key_frame_requests) = call.tick(at(1204));
        assert_eq!(2, rtp_to_send.len());
        assert_eq!(
            Some(protos::sfu_to_device::Stats {
                target_send_rate_kbps: Some(600),
                ideal_send_rate_kbps: Some(0),
                allocated_send_rate_kbps: Some(0),
            }),
            get_stats(&rtp_to_send, demux_id1)
        );
        assert_eq!(
            Some(protos::sfu_to_device::Stats {
                target_send_rate_kbps: Some(600),
                ideal_send_rate_kbps: Some(0),
                allocated_send_rate_kbps: Some(0),
            }),
            get_stats(&rtp_to_send, demux_id2)
        );

        // But do resend after 1001ms
        let (rtp_to_send, _outgoing_key_frame_requests) = call.tick(at(1904));
        assert_eq!(
            vec![
                (
                    demux_id1,
                    create_server_to_client_rtp(5, &expected_update_payload)
                ),
                (
                    demux_id2,
                    create_server_to_client_rtp(5, &expected_update_payload)
                )
            ],
            rtp_to_send
        );

        // And more stats a little later.
        let (rtp_to_send, _outgoing_key_frame_requests) = call.tick(at(2205));
        assert_eq!(2, rtp_to_send.len());
        assert_eq!(
            Some(protos::sfu_to_device::Stats {
                target_send_rate_kbps: Some(600),
                ideal_send_rate_kbps: Some(0),
                allocated_send_rate_kbps: Some(0),
            }),
            get_stats(&rtp_to_send, demux_id1)
        );
        assert_eq!(
            Some(protos::sfu_to_device::Stats {
                target_send_rate_kbps: Some(600),
                ideal_send_rate_kbps: Some(0),
                allocated_send_rate_kbps: Some(0),
            }),
            get_stats(&rtp_to_send, demux_id2)
        );
    }

    #[test]
    fn send_forwarding_video_updates() {
        let now = Instant::now();
        let system_now = SystemTime::now();
        let at = |millis| now + Duration::from_millis(millis);
        let get_forwarding_video_demux_ids =
            |from_server: &[RtpToSend], receiver_demux_id: DemuxId| -> Option<Vec<DemuxId>> {
                let (_demux_id, rtp) = from_server
                    .iter()
                    .find(|(demux_id, _rtp)| *demux_id == receiver_demux_id)?;
                let proto = protos::SfuToDevice::decode(rtp.payload()).ok()?;
                let mut demux_ids: Vec<DemuxId> = proto
                    .current_devices?
                    .demux_ids_with_video
                    .iter()
                    .map(|demux_id| DemuxId::try_from(*demux_id).unwrap())
                    .collect();
                demux_ids.sort();
                Some(demux_ids)
            };

        let mut call = create_call(b"call_id", now, system_now);
        let demux_id1 = add_client(&mut call, "1", 1, at(1));
        let demux_id2 = add_client(&mut call, "2", 2, at(2));
        let demux_id3 = add_client(&mut call, "3", 3, at(3));

        let (from_server, _outgoing_key_frame_requests) = call.tick(at(4));
        // Nothing to forward yet
        assert_eq!(
            Some(vec![]),
            get_forwarding_video_demux_ids(&from_server, demux_id1)
        );
        assert_eq!(
            Some(vec![]),
            get_forwarding_video_demux_ids(&from_server, demux_id2)
        );
        assert_eq!(
            Some(vec![]),
            get_forwarding_video_demux_ids(&from_server, demux_id3)
        );

        // Send some video from client2 so the incoming rate goes up.
        for seqnum in 0..10 {
            let mut to_server = create_video_rtp(
                demux_id2,
                LayerId::Video0,
                1,
                1,
                seqnum,
                Some(PixelSize {
                    width: 640,
                    height: 480,
                }),
            );
            call.handle_rtp(demux_id2, to_server.borrow_mut(), at(5))
                .unwrap();
        }

        let (from_server, _outgoing_key_frame_requests) = call.tick(at(1006));
        assert_eq!(
            Some(vec![demux_id2]),
            get_forwarding_video_demux_ids(&from_server, demux_id1)
        );
        assert_eq!(
            Some(vec![]),
            get_forwarding_video_demux_ids(&from_server, demux_id2)
        );
        assert_eq!(
            Some(vec![demux_id2]),
            get_forwarding_video_demux_ids(&from_server, demux_id3)
        );

        // Make sure we keep forwarding even after getting a key frame
        let mut to_server = create_video_rtp(
            demux_id2,
            LayerId::Video0,
            1,
            1,
            11,
            Some(PixelSize {
                width: 640,
                height: 480,
            }),
        );
        call.handle_rtp(demux_id2, to_server.borrow_mut(), at(1007))
            .unwrap();

        let (from_server, _outgoing_key_frame_requests) = call.tick(at(2008));
        assert_eq!(
            Some(vec![demux_id2]),
            get_forwarding_video_demux_ids(&from_server, demux_id1)
        );
        assert_eq!(
            Some(vec![]),
            get_forwarding_video_demux_ids(&from_server, demux_id2)
        );
        assert_eq!(
            Some(vec![demux_id2]),
            get_forwarding_video_demux_ids(&from_server, demux_id3)
        );

        // Request a really low max recv rate to prevent things from being forwarded
        let mut to_server = create_max_receive_rate_request(DataRate::from_kbps(1));
        call.handle_rtp(demux_id1, to_server.borrow_mut(), at(2009))
            .unwrap();

        let (from_server, _outgoing_key_frame_requests) = call.tick(at(3010));
        assert_eq!(
            Some(vec![]),
            get_forwarding_video_demux_ids(&from_server, demux_id1)
        );
        assert_eq!(
            Some(vec![]),
            get_forwarding_video_demux_ids(&from_server, demux_id2)
        );
        assert_eq!(
            Some(vec![demux_id2]),
            get_forwarding_video_demux_ids(&from_server, demux_id3)
        );
    }

    #[test]
    fn test_leave_message() {
        let now = Instant::now();
        let system_now = SystemTime::now();
        let at = |millis| now + Duration::from_millis(millis);

        let mut call = create_call(b"call_id", now, system_now);

        let demux_id1 = add_client(&mut call, "1", 1, at(99));
        let demux_id2 = add_client(&mut call, "2", 2, at(200));
        assert_eq!(2, call.clients.len());

        // Clear out updates.
        let (_rtp_to_send, _outgoing_key_frame_requests) = call.tick(at(300));

        call.handle_rtp(demux_id1, create_leave_rtp().borrow_mut(), at(400))
            .unwrap();
        assert_eq!(1, call.clients.len());

        let (rtp_to_send, _outgoing_key_frame_requests) = call.tick(at(400));
        let expected_update_payload = encode_proto(create_sfu_to_device(
            true,
            Some(("1_active_speaker_id", demux_id1)),
            &[demux_id2],
        ));
        assert_eq!(
            vec![(
                demux_id2,
                create_server_to_client_rtp(2, &expected_update_payload)
            )],
            rtp_to_send
        );
    }
}
